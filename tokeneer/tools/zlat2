# Praxis Z styles and tools
#
# Copyright (c) 2008, Praxis High Integrity Systems Limited
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#------------------------------------------------------------------------------
# Command     : zlat2
#
# Son of zlat ...
#   a redesign and enhancement of the original zlat script written by
#   Jonathan Hammond.
#
# Files are modified in situ (with backup).
# Files are not overwritten until the processing has succeeded.
#
# All LaTeX lines introduced are terminated with '%%% ZLAT', and are
# disregarded by further invokations of this script.
#
# Z functions
#   1. Generates LaTeX \index and \label for each Z token.
#   2. Generates cross-references (-x option).
#   3. Generates state summary (-s option), requires exactly one schema
#      marked as complete state (see below).
# Directives may be attached to Z environments.
# They must be on the same line as the \begin, eg
#    \begin{schema}{MySchema} %%% zlat: state noxref
# All white space, except that separating the keywords, is optional.
# Recognised keywords are:
#   noxref       don't generate cross-references (Zref) for this Z para
#   state        this schema specifies complete Z state
#
# Ada functions
#   1. Insert Ada source corresponding to a traceunit here (-a option).
#      Replaces lines containing "%%% ada: traceunit-name" with a LaTeX
#      figure containing its source.
#      Source files must be available in the current directory.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# User options
#------------------------------------------------------------------------------

require "getopts.pl";

( &Getopts('vxsda') && @ARGV ) || die <<USAGE;
Usage: zlat2 [-x] [-s] [-d] [-a] filename (without .tex)

          -x     generate Z cross-reference environments
          -s     generate Z state component summary in file z-state.tex

          -a     insert Ada source

          -d     delete all lines generated by previous zlat2s

       Note: if the -d option is specified then -s option is ignored

USAGE

$verbose++;
$doxref = $opt_x;
$delete_zlat = $opt_d;
$dostatesum = ($opt_s && !$delete_zlat);
$doada = $opt_a;

#------------------------------------------------------------------------------
# Main processing
#------------------------------------------------------------------------------

$fh = 'fh00';      # unique filehandles

# global variables required to produce Z state summary ...
$sch_name = '';    # name of last defined schema found
$state_sch = '';   # name of complete Z state schema
@sch_names = ();   # list of all schema names
%sch_decl = ();    # declaration part of each vertical schema
@sch_types = ();   # list of schema types used in Z state
%stype_found = (); # records schema types already found in Z state

# global variables for Ada source inclusion
%ada_trace = ();   # traceunit -> LaTeX command for setting Ada source

# Process LaTeX file
&DoLaTeXFile($ARGV[0]);

# Success! -- backup processed files, and make new ones current.
print STDERR "Backing up previous versions ...\n" if $verbose;
foreach $file (keys %LaTeXFileDone)
{
  rename("$file.tex","$file.bak");
  rename("$file.new","$file.tex");
}

if ($dostatesum && !$state_sch) {
  warn "State summary requested (-s option) but state schema not found\n";
}
elsif ($dostatesum && $state_sch) {
  &DoStateSummary;
}

#------------------------------------------------------------------------------
# End of processing
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# DoLaTeXFile ( filename )
#
# Recursively process LaTeX file inclusion tree.
# Input from filename.tex.
# Output to filename.new.
#------------------------------------------------------------------------------

sub DoLaTeXFile # LaTeXfile
{
  local($LaTeXfile) = @_;

  local($LaTeXin) = $fh++;
  local($LaTeXout) = $fh++;

  local($Zpara);

  if( $LaTeXFileDone{$LaTeXfile} )
  {
    warn "Ignoring LaTeX file $LaTeXfile (already processed)\n";
    return;
  }

  open($LaTeXin,"<$LaTeXfile.tex") ||
    ( warn "Can't read $LaTeXfile.tex\n", return );
  open($LaTeXout,">$LaTeXfile.new") || die "Can't create LaTeX output file\n";
  
  $LaTeXFileDone{$LaTeXfile}++;
  print STDERR "Processing $LaTeXfile ...\n" if $verbose;

 LaTeXline:
  while(<$LaTeXin>)
  {
    # ignore lines inserted by previous runs of zlat
    next LaTeXline if /%%% ZLAT$/;

    # input and include (must be on line by itself)
    if( /^\s*\\(input|include)\s*\{([^\}]*)\s*\}/ )
    {
      print $LaTeXout $_;
      &DoLaTeXFile($2);
      next LaTeXline;
    }

    # Z paragraphs
    if (/^\s*\\begin\{\s*(zed|axdef|schema|gendef|syntax)\s*\}/)
    {
      $Zpara = $_;
      # swallow lines until corresponding \end found
      do {
	$_ = <$LaTeXin>;
	$Zpara .= $_;
      } until /^\s*\\end\{\s*$1\s*\}/;

      &DoZpara($LaTeXout,$Zpara);

      next LaTeXline;
    }

    # Ada source inclusion
    if ($doada && /%%%\s+ada:\s*(\S+)/)
    {
      &DoAdaTrace($1);
    }

    # otherwise, just copy through
    print $LaTeXout $_;
  }
  close($LaTeXin); close($LaTeXout);
}


#------------------------------------------------------------------------------
# DoZpara ( filehandle, Z paragraph )
#
# Z paragraph contains the \begin and \end lines.
#
# DoZpara must print the Z paragraph (unchanged) as well as do the rest of its
# processing.
#------------------------------------------------------------------------------

sub DoZpara # filehandle, Zpara
{
  local($LaTeXout,$Zpara) = @_;

  if( $delete_zlat )
  {
    print $LaTeXout $Zpara;
    return;
  }

  local(@Z) = split('\n',$Zpara);  # local copy for modification
  local($_);
  %ZNamesInThisPara = ("cbstart", 1, "cbend", 1);

  # Reset directives and check for current Z para?
  %Directive = ();
  if( $Z[0] =~ /%%%\s*zlat\s*:\s*(.*)/ )
  {
    grep(&DoDirective($_),split(' ',$1));
  }

  # paragraph processing based on 'create_tmp' of original zlat

  foreach (@Z)
  {
    # N.B. do not need to look for start of theorems - no work to do
    # for index as theorems do not define any new Z

    # do not want to be confused by ampersands in syntax envs - so remove
    $in_syntax && tr/&//d;

    if (/^\s*\%/){
      if (/^\s*\%.*THORN-TRACE-TO.*/) {
	$thorn_trace = 1;
      }
      # note that Z paras 'hidden' from printing by '%%' are ignored
    }
    elsif ($in_zed) {
      # remove any fUZZ tabs at start of line
      /^\s*\\t\d+\s+(.*)$/ && ($_ = $1);
      
      if($in_given_sets) {
	if (/^[~\s]*([\w\\,\s]+)\](\\\\|\\also)?/o) {
	  # Found the end of a given sets definition
	  $in_given_sets = 0;
	  &DefineZList($LaTeXout,$1);
	}
	elsif (/^[~\s]*([\w\\,\s]+)\\\\/o) {
	  # The middle bit of a given set definition
	  &DefineZList($LaTeXout,$1);
	}
	else {
	  die "Cannot cope with given sets line:\n    $_\n";
	}
      }
      elsif(/^[~\s]*([\w\\]*)\s*\\defs/o){ 
	# found horizontal schema definition
        if ($dostatesum) {
          $sch_name = $1;
          push(@sch_names,$sch_name);
        }

	&DefineZName($LaTeXout,$1);
	$in_zed = 1; $in_free = 0; $in_horiz = 1;
      }
      elsif(/^[~\s]*([\w\s\\]*)[~\s]*(\[.+\])?\s*==/o){
	# found abbreviation definition - if more than one word on LHS
	# of '==' assume formal generic param(s) are 'X' or 'Y'
	foreach $z_name(split(/\s+/o, $1)){
	  if ($z_name ne '' && !($z_name =~ /^[xXyY]$/o)){
	    &DefineZName($LaTeXout,$z_name);
	  }
	}
	$in_free = 0;
      }
      elsif(/^[~\s]*([\w\\]*)\s*::=\s*(.*)\s*(\\\\|\\also)?/o){
	# found free type definition
	$in_free = 1;
	&DefineZName($LaTeXout,$1);
	&DefineZFtype($LaTeXout,$2);
      }
      elsif ($in_horiz) {
	if (/\\also/ ) { $in_horiz = 0; }
      }
      elsif(/^\s*\[(.+)\](\\\\|\\also)?/o) {
	# found a given set definition which may contain more than
	# one given set
	&DefineZList($LaTeXout,$1);
      }
      elsif(/^\s*\[(.+)(\\\\|\\also)/o) {
	# Found start of given set split over multiple lines
	$in_given_sets = 1;
	&DefineZList($LaTeXout,$1);
      }
      elsif ($in_free) {
	if (/^[~\s]*(.+)/o && !/^\s*\\end\{\w+\}/o){
	  &DefineZFtype($LaTeXout,$1);
	} else {
	  $in_free = 0;
	}
      }
      elsif ($in_def) {
	if(/^\s*([\w\\,\s]+):/o){
	  # found function or variable definition(s)
	  &DefineZList($LaTeXout,$1);
	} elsif (/^\s*\\where/o){$in_zed = 0; $in_def = 0;}
      }
    }
    else {
      if(/^\s*\\begin\{schema\}\{([\w\\]*)\}/o){ 
	# found start of vertical schema paragraph
        if ($dostatesum) {
          $sch_name = $1;
          push(@sch_names,$sch_name);

          # suck up schema's declaration part ...
          $decl = '';
          foreach(split('\n',$Zpara)) {
            (/^\s*\\begin/o) && next;
            (/^\s*(\\end\{schema\}|\\where)/o) && last;
            $decl .= $_."\n";
          }
          $sch_decl{$sch_name} = $decl;
        }

	&DefineZName($LaTeXout,$1);
      }
      elsif(/^\s*\\begin\{(zed|syntax)\}/o){ 
	# found start of 'zed' or 'syntax' Z paragraph
	($1 eq 'syntax') && ($in_syntax = 1);
	$in_zed = 1;
      }
      elsif(/^\s*\\begin\{(axdef|gendef)\}/o){
	# found start of  'axdef' or 'gendef'  Z paragraph
	$in_zed = 1;
	$in_def = 1;
      }
    } # if
    
    # check if end of Z paragraph reached
    if (/^\s*\\end\{(schema|zed|syntax|axdef|gendef|(gen)?theorem)\}/o)
    {
      ($1 eq 'schema') && push(@linenos, $.+1);
      $in_zed = $in_def = $in_syntax = $in_free = $in_horiz = 0;
    }

  }

  print $LaTeXout $Zpara;

  if( $doxref && !$Directive{'noxref'})
  {
    # Backward refs to Z names already declared
    # ... need to remove names defined in current paragraph
    $* = 1;
    $firstref = 1;
    local(%done);
    local(@token) =
      grep(!/^\\\\$/ && $z_names{$_} && !$ZNamesInThisPara{$_} && !$done{$_} && ++$done{$_},
	   split(/[^\w\\]+/,$Zpara));
    # print STDERR join(',',@token),"\n";
    foreach $token (@token)
    {
	print $LaTeXout "\\begin{Zref}%%% ZLAT\n" if $firstref;
	print $LaTeXout "\\zrefsep" unless $firstref;
        # '\zref' macro: 1st param is Z name as printed;
        #                2nd param is Z name as used in LaTeX label name.
	print $LaTeXout "\\zref{$token}";
	$token =~ s/\\//g;
	print $LaTeXout "{$token}%%% ZLAT\n";
	$firstref = 0;
    }
    print $LaTeXout "\\end{Zref}%%% ZLAT\n" unless $firstref;
    $* = 0;
  }

  $dostatesum && $Directive{'state'} && ($state_sch = $sch_name);
}


#------------------------------------------------------------------------------
# DefineZList ( filehandle, Zname list )
#
# Takes a comma-separated list of Z names, and outputs \index and \label for
# each.
#------------------------------------------------------------------------------

sub DefineZList # filehandle, comma-sep list of Z names
{
  local($LaTeXout,$list) = @_;

  foreach $z_name (split(/,[~\s]*/o, $list))
  {
    &DefineZName($LaTeXout,$z_name)
  }
}


#------------------------------------------------------------------------------
# DefineZFtype ( filehandle, ftype line )
#
# Takes a line from a free type definition, and outputs \index and \label for
# each Z name.
#------------------------------------------------------------------------------

sub DefineZFtype # filehandle, line from a free type definition
{
  local($LaTeXout,$line) = @_;

  # split $line on free type branch separators
  foreach (split(/(\||\\mid)[~\s]*/o, $line))
  {
    # first word of a branch is an atom or a constructor (if not end of line)
    (/([\w\\]+)/o) && ($1 ne '\\\\') && ($1 ne '\\also') &&
      &DefineZName($LaTeXout,$1)
  }
}


#------------------------------------------------------------------------------
# DefineZName ( filehandle, Z name )
#
# Takes a Z name, and outputs \index and \label for it.
#------------------------------------------------------------------------------

sub DefineZName # filehandle, Z name
{
  local($LaTeXout,$z_name) = @_;

  return if $z_name =~ /(cbstart|cbend)/;
  
  # only put $z_name in $z_names if it is a single word (excluding '\_')
  if ($z_name =~ /^(\\_\s*)?([\w\\]+)(\s*\\_)?\s*$/o)
  {
    $z_name = $1.$2.$3;
    $z_names{$z_name}++;
    $ZNamesInThisPara{$z_name}++;
    print $LaTeXout "\\index{ZI:$z_name}";
    $z_name =~ s/\\//g;
    print $LaTeXout "\\label{ZL:$z_name} %%% ZLAT\n";
  }
}


#------------------------------------------------------------------------------
# DoDirective ( directive )
#
# Takes a directive and processes it
#------------------------------------------------------------------------------

sub DoDirective # directives
{
  local($directive) = @_;

  if( $directive =~ /^(state|noxref)$/ )
  {
    $Directive{$directive}++;
  }
  else
  {
    warn "Unrecognised directive: $directive\n";
  }
}


#------------------------------------------------------------------------------
# DoStateSummary
#
# Generates complete Z state summary
#------------------------------------------------------------------------------

sub DoStateSummary # Z state summary
{
  open(STATE,">z-state.tex") || die "Can't write to z-state.tex\n";
  print STATE <<PREAMBLE;
\\begin{tabbing}
xx \\= xx \\= xx \\= xx \\= xx \\= xx \\= xx \\= \\kill
PREAMBLE

  # prepare %mark for finding schema types on rhs of declarations
  grep($mark{$_}++,@sch_names);

  print STATE "\\textbf\{State Components\}\\\\\n";

  &DoStateSchema($state_sch);

  print STATE "\\\\\n\\\\\n\\\\\n\\textbf\{Schema Types\}\\\\\n";

  # now print out component summaries of schema types
  foreach (@sch_types) {
    &DoStateSchema($_);
  }

  print STATE <<POSTAMBLE;
\\end{tabbing}
POSTAMBLE
  close(STATE);
}


#------------------------------------------------------------------------------
# DoStateSchema (schema_name)
#
# Recursively prints components of a Z state schema
#------------------------------------------------------------------------------

sub DoStateSchema # Z state summary for input schema
{
  local($sch_name) = @_;
  local($line); local($dec); local($sch); local($rhs); local($stype);
  local($z_name);

  # This schema is ...
  ($z_name = $sch_name) =~ s/\\//g;
  print STATE "\\\\\n\$$sch_name\$ (p. \\pageref{ZL:$z_name})\\+";

  foreach $line (split('\n',$sch_decl{$sch_name})) {
    # we assume ';' is always a declaration separator (ie we do not
    # cater for complex set comprehensions on RHS of a ':')

    foreach $dec (split(';',$line)) {
      if ($dec !~ /:/o) {
	# This is an included state schema
        ($sch) = ($dec =~ /([\w\\]+)/o);
        if ($sch_decl{$sch}) {
          &DoStateSchema($sch);
        } elsif ($sch !~ /^\\also$/o) {
          # Note: horizontal schemas not currently handled
          warn "No declaration part found for state schema $sch\n";
        }
      } else {
        $dec =~ s/\\\\//;  # removes '\\' from end of lines

        # check for schema types on RHS of ':'
        ($rhs) = ($dec =~ /:(.*)$/);
        foreach $stype (grep($mark{$_}, split(/[~\s]+/, $rhs))) {
          !$stype_found{$stype} && (push(@sch_types, $stype));
          $stype_found{$stype}++;
        }

	# This is some real state
        print STATE "\\\\\n\$$dec\$";
      }
    }
  }
  # end of schema
  print STATE "\\-";
}

#------------------------------------------------------------------------------
# DoAdaTrace (traceunit)
#
# output LaTeX source to include Ada source in situ
#------------------------------------------------------------------------------

sub DoAdaTrace # traceunit
{
  local($traceunit) = @_;
  local($suffix,$package,$rest,$adafile);

  if ($ada_trace{$traceunit} eq "")
  {
    ($suffix,$package,$rest) = split(/\./,$traceunit,3);
    $suffix =~ tr/A-Z/a-z/;
    $adafile = "$package.$suffix";
    &DoAdaFile($adafile);
  }

  if ($ada_trace{$traceunit} eq "")
  {
    warn("Ada traceunit $traceunit not found.\n");
  }
  else
  {
    print $LaTeXout $ada_trace{$traceunit}," %%% ada: $traceunit\n";
  }
}

#------------------------------------------------------------------------------
# DoAdaFile (filename)
#
# Search Ada file for traceunits, and put LaTeX commands in %ada_trace
#------------------------------------------------------------------------------

sub DoAdaFile # filename
{
  local($adafile) = @_;
  local($start,$tu_name,$tu_start,$end) = (0,"",0,0);

  return if $AdaFileDone{$adafile};

  $AdaFileDone{$adafile}++;
  open(ADA,"<$adafile") || (warn("Can't read $adafile.\n"), return);

adaline:
  while(<ADA>)
  {
    if (/\s*----------/)
    {
      $start = $.;
      next adaline;
    }

    if( /\s*--\s*Traceunit\s*:\s*(\S+)/ || eof(ADA))
    {
      # do previous traceunit, if any
      if ($tu_name ne "")
      {
	$end = $start - 1;
        $end = $. if eof(ADA);
	$ada_trace{$tu_name} = 
          "\\VautoSubF\[5\]\{$tu_start\}\{$end\}\{$adafile\}\{$tu_name\}\{src:$tu_name\}";
      }
      $tu_name = $1; $tu_start = $start;
      next adaline;
    }
  }

  close(ADA);
}



