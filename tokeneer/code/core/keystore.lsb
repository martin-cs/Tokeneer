           *******************************************************
                            Listing of SPARK Text
                              Examiner GPL 2011
             Copyright (C) 2011 Altran Praxis Limited, Bath, U.K.
           *******************************************************


                        DATE : 05-SEP-2011 15:33:12.89

Line
   1  ------------------------------------------------------------------
   2  -- Tokeneer ID Station Core Software
   3  --
   4  -- Copyright (2003) United States Government, as represented
   5  -- by the Director, National Security Agency. All rights reserved.
   6  --
   7  -- This material was originally developed by Praxis High Integrity
   8  -- Systems Ltd. under contract to the National Security Agency.
   9  --
  10  -- Modifications to proof annotations by Phil Thornley, April 2009
  11  ------------------------------------------------------------------
  12  
  13  ------------------------------------------------------------------
  14  -- KeyStore
  15  --
  16  -- Implementation Notes:
  17  --    None.
  18  --
  19  ------------------------------------------------------------------
  20  
  21  with AuditLog,
  22       AuditTypes,
  23       BasicTypes,
  24       CryptoTypes,
  25       KeyStore.Interface;
  26  
  27  use type BasicTypes.Unsigned32T;
  28  use type CryptoTypes.IssuerT;
  29  use type KeyStore.Interface.ReturnValueT;
  30  use type KeyStore.Interface.MaskT;
  31  
  32  package body KeyStore
  33  --# Own Store is KeyStore.Interface.Store &
  34  --#     State is ThisTISInfo;
  35  is
  36  
  37     ----------------------------------------------------------------
  38     -- Types
  39     ----------------------------------------------------------------
  40     type OptionalPrivateKeyT is record
  41        IsPresent : Boolean;
  42        Owner     : CryptoTypes.IssuerT;
  43     end record;
  44  
  45     type IsSystemT is array (Interface.ReturnValueT) of Boolean;
  46  
  47     ----------------------------------------------------------------
  48     -- State
  49     ----------------------------------------------------------------
  50  
  51     ThisTISInfo : OptionalPrivateKeyT;
  52  
  53  
  54     -- Key handles are unsigned 32 bit words, with zero being a null
  55     -- key handle.
  56     NullKey : constant BasicTypes.Unsigned32T := 0;
  57  
  58     -- Crypto errors can be groupes as a System Error, or a User Error.
  59     IsSystem : constant IsSystemT := IsSystemT'(
  60                   Interface.Ok                         => False,
  61                   Interface.HostMemory                 => True,
  62                   Interface.GeneralError               => True,
  63                   Interface.FunctionFailed             => True,
  64                   Interface.ArgumentsBad               => False,
  65                   Interface.AttributeReadOnly          => False,
  66                   Interface.AttributeTypeInvalid       => False,
  67                   Interface.AttributeValueInvalid      => False,
  68                   Interface.DataInvalid                => False,
  69                   Interface.DataLenRange               => False,
  70                   Interface.DeviceError                => True,
  71                   Interface.DeviceMemory               => True,
  72                   Interface.FunctionCanceled           => True,
  73                   Interface.KeyHandleInvalid           => False,
  74                   Interface.KeySizeRange               => False,
  75                   Interface.KeyTypeInconsistent        => False,
  76                   Interface.KeyFunctionNotPermitted    => False,
  77                   Interface.MechanismInvalid           => False,
  78                   Interface.MechanismParamInvalid      => False,
  79                   Interface.ObjectHandleInvalid        => False,
  80                   Interface.OperationActive            => True,
  81                   Interface.OperationNotInitialized    => True,
  82                   Interface.SignatureInvalid           => False,
  83                   Interface.SignatureLenRange          => False,
  84                   Interface.TemplateIncomplete         => False,
  85                   Interface.TemplateInconsistent       => False,
  86                   Interface.BufferTooSmall             => True,
  87                   Interface.CryptokiNotInitialized     => True,
  88                   Interface.CryptokiAlreadyInitialized => True
  89                   );
  90  
  91  
  92     ------------------------------------------------------------------
  93     -- Local Subprograms
  94     --
  95     ------------------------------------------------------------------
  96  
  97     ------------------------------------------------------------------
  98     -- ConvertRetValToText
  99     --
 100     -- Description:
 101     --    Produces a String representing the error code
 102     --
 103     -- Implementation Notes:
 104     --    None.
 105     --
 106     ------------------------------------------------------------------
 107     function ConvertRetValToText(RetVal : Interface.ReturnValueT;
 108                                  Op     : String) return AuditTypes.DescriptionT
 109     is
 110     --# hide ConvertRetValToText;
 111        Result : AuditTypes.DescriptionT := AuditTypes.NoDescription;
 112        TheString : String := "Crypto Library Error in " & Op & " : " &
 113                                 Interface.ReturnValueT'Image(RetVal);
 114     begin
 115        if TheString'Length <= AuditTypes.DescriptionT'Last then
 116           Result(1..TheString'Length) := TheString;
 117        else
 118           Result := TheString(1..AuditTypes.DescriptionT'Last);
 119        end if;
 120  
 121        return Result;
 122     end ConvertRetValToText;
 123  
 124     ------------------------------------------------------------------
 125     -- Digest
 126     --
 127     -- Description:
 128     --    Attempts to digest the raw cerificate data
 129     --
 130     -- Implementation Notes:
 131     --    None.
 132     --
 133     ------------------------------------------------------------------
 134     procedure Digest(Mechanism   : in     CryptoTypes.AlgorithmT;
 135                      RawCertData : in     CertTypes.RawDataT;
 136                      TheDigest   :    out Interface.DigestT;
 137                      Success     :    out Boolean)
 138     --# global in     Interface.Store;
 139     --#        in     Clock.Now;
 140     --#        in     ConfigData.State;
 141     --#        in out AuditLog.State;
 142     --#        in out AuditLog.FileState;
 143     --# derives TheDigest,
 144     --#         Success            from Mechanism,
 145     --#                                 RawCertData,
 146     --#                                 Interface.Store &
 147     --#         AuditLog.State,
 148     --#         AuditLog.FileState from Mechanism,
 149     --#                                 RawCertData,
 150     --#                                 Interface.Store,
 151     --#                                 AuditLog.State,
 152     --#                                 AuditLog.FileState,
 153     --#                                 Clock.Now,
 154     --#                                 ConfigData.State;
 155     is
 156        RetValIni : Interface.ReturnValueT;
 157        -- Initialize the update and final returns to Ok, so a
 158        -- system fault isn't raised if an update is not executed.
 159        RetValUpd,
 160        RetValFin : Interface.ReturnValueT := Interface.Ok;
 161  
 162        LoopMax : Positive;
 163        BytesLeft : Positive;
 164  
 165        Block : Interface.HundredByteArrayT;
 166        Size : BasicTypes.Unsigned32T := 100;
 167  
 168  
 169        ------------------------------------------------------------------
 170        -- GetBlock
 171        --
 172        -- Description:
 173        --    Produces the required data block from the raw certificate
 174        --
 175        -- Implementation Notes:
 176        --    None.
 177        --
 178        ------------------------------------------------------------------
 179        function GetBlock(Data      : CertTypes.RawCertificateT;
 180                          BlockNo   : Positive;
 181                          BlockSize : BasicTypes.Unsigned32T)
 182                    return Interface.HundredByteArrayT
 183        --# pre 1 <= BlockNo and
 184        --#     BlockNo <= 41 and
 185        --#     1 <= BlockSize and
 186        --#     BlockSize <= 100 and
 187        --#     Positive(BlockSize) + (BlockNo - 1) * 100 <= CertTypes.RawCertificateI'Last;
 188        is
 189           Result : Interface.HundredByteArrayT :=
 190                       Interface.HundredByteArrayT'(others => ' ');
 191        begin
 192           for i in CertTypes.RawCertificateI range 1 .. 100 loop
 193              --# assert 1 <= BlockNo and
 194              --#        BlockNo <= 41 and
 195              --#        1 <= BlockSize and
 196              --#        BlockSize <= 100 and
 197              --#        1 <= i and i <= 100 and
 198              --#        BasicTypes.Unsigned32T(i) <= BlockSize;
 199  
 200              --# check i + (BlockNo - 1) * 100 in 1 .. 4096;
 201              Result(i) := Data(i + (BlockNo - 1) * 100);
 202              exit when BasicTypes.Unsigned32T(i) = BlockSize;
 203           end loop;
 204  
 205           return Result;
 206        end GetBlock;

+++        Flow analysis of subprogram GetBlock performed: 
           no errors found.

 207  
 208  
 209     begin
 210        TheDigest := Interface.NullDigest;
 211  
 212        Interface.DigestInit(Mechanism   => Mechanism,
 213                             ReturnValue => RetValIni);
 214        -- is Mechanism is dom Digest?
 215        if RetValIni = Interface.Ok then
 216  
 217           -- If so perform digest...
 218           LoopMax := ( (RawCertData.DataLength - 1) / 100 ) + 1;
 219           BytesLeft := RawCertData.DataLength;
 220  
 221           --# check LoopMax <= 41;
 222  
 223           for i in Positive range 1..LoopMax loop
 224  
 225              --# assert LoopMax = ((RawCertData.DataLength - 1) / 100) + 1 and
 226              --#        LoopMax = LoopMax% and
 227              --#        LoopMax% <= 41 and
 228              --#        1 <= i and i <= LoopMax and
 229              --#        BytesLeft = (RawCertData.DataLength) - (i - 1) * 100 and
 230              --#        (BytesLeft <= 100 -> i = LoopMax%) and
 231              --#        (i = 41 -> BytesLeft <= 96) and
 232              --#        1 <= RawCertData.DataLength and
 233              --#        RawCertData.DataLength <= 4096 and
 234              --#        1 <= Size and Size <= 100 and
 235              --#        RetValIni = Interface.Ok and
 236              --#        RetValFin = Interface.Ok;
 237  
 238              if BytesLeft < 100 then
 239                 Size := BasicTypes.Unsigned32T(BytesLeft);
 240              end if;
 241  
 242              Block := GetBlock(Data      => RawCertData.RawData,
 243                                BlockNo   => i,
 244                                BlockSize => Size);
 245  
 246              Interface.DigestUpdate(DataBlock   => Block,
 247                                     ByteCount   => Size,
 248                                     ReturnValue => RetValUpd);
 249  
 250              exit when RetValUpd /= Interface.Ok or
 251                     i = LoopMax;
 252  
 253              --# check BytesLeft /= 100;
 254  
 255              BytesLeft := BytesLeft - 100;
 256  
 257           end loop;
 258  
 259           -- If everything OK, then get the calculated digest
 260           if RetValUpd = Interface.Ok then
 261  
 262              Interface.DigestFinal(Digest       => TheDigest,
 263                                    ReturnValue  => RetValFin);
 264           end if;
 265        end if;
 266        --# assert True;
 267  
 268        Success := RetValIni = Interface.Ok and
 269                   RetValUpd = Interface.Ok and
 270                   RetValFin = Interface.Ok;
 271  
 272        if IsSystem(RetValIni) then
 273           AuditLog.AddElementToLog(
 274                  ElementID    => AuditTypes.SystemFault,
 275                  Severity     => AuditTypes.Warning,
 276                  User         => AuditTypes.NoUser,
 277                  Description  => ConvertRetValToText(RetValIni, "DigestInit")
 278                  );
 279        end if;
 280  
 281        if IsSystem(RetValUpd) then
 282           AuditLog.AddElementToLog(
 283                  ElementID    => AuditTypes.SystemFault,
 284                  Severity     => AuditTypes.Warning,
 285                  User         => AuditTypes.NoUser,
 286                  Description  => ConvertRetValToText(RetValUpd, "DigestUpdate")
 287                  );
 288        end if;
 289  
 290        if IsSystem(RetValFin) then
 291           AuditLog.AddElementToLog(
 292                  ElementID    => AuditTypes.SystemFault,
 293                  Severity     => AuditTypes.Warning,
 294                  User         => AuditTypes.NoUser,
 295                  Description  => ConvertRetValToText(RetValFin, "DigestFinal")
 296                  );
 297        end if;
 298     end Digest;

+++        Flow analysis of subprogram Digest performed: no 
           errors found.

 299  
 300  
 301     ------------------------------------------------------------------
 302     -- DoFind
 303     --
 304     -- Description:
 305     --    Calls the Crypto Find operations in order, and attempts to find
 306     --    HandleCount handles. Returns these in a HandleArray and a
 307     --    count of the actual number found.
 308     --
 309     -- Implementation Notes:
 310     --    None
 311     --
 312     ------------------------------------------------------------------
 313     procedure DoFind(Template    : in     Interface.KeyTemplateT;
 314                      HandleCount : in out BasicTypes.Unsigned32T;
 315                      Handles     :    out Interface.HandleArrayT)
 316     --# global in     Interface.Store;
 317     --#        in     Clock.Now;
 318     --#        in     ConfigData.State;
 319     --#        in out AuditLog.State;
 320     --#        in out AuditLog.FileState;
 321     --# derives AuditLog.State,
 322     --#         AuditLog.FileState from Interface.Store,
 323     --#                                 AuditLog.State,
 324     --#                                 AuditLog.FileState,
 325     --#                                 Clock.Now,
 326     --#                                 ConfigData.State,
 327     --#                                 HandleCount,
 328     --#                                 Template &
 329     --#         HandleCount,
 330     --#         Handles            from Interface.Store,
 331     --#                                 HandleCount,
 332     --#                                 Template;
 333     is
 334        RetValIni : Interface.ReturnValueT;
 335        -- Initialize the find and final returns to Ok, so a
 336        -- system fault isn't raised if a FindObjects is not executed.
 337        RetValDo,
 338        RetValFin : Interface.ReturnValueT := Interface.Ok;
 339     begin
 340        Handles := Interface.HandleArrayT'(others => NullKey);
 341        Interface.FindObjectsInit(Template    => Template,
 342                               ReturnValue => RetValIni);
 343  
 344        if RetValIni = Interface.Ok then
 345           Interface.FindObjects(HandleCount   => HandleCount,
 346                                 ObjectHandles => Handles,
 347                                 ReturnValue   => RetValDo);
 348  
 349           if RetValIni = Interface.Ok then
 350              Interface.FindObjectsFinal(ReturnValue => RetValFin);
 351           end if;
 352        end if;
 353  
 354        if IsSystem(RetValIni) then
 355  
 356           AuditLog.AddElementToLog(
 357                  ElementID    => AuditTypes.SystemFault,
 358                  Severity     => AuditTypes.Warning,
 359                  User         => AuditTypes.NoUser,
 360                  Description  => ConvertRetValToText(RetValIni, "FindObjectsInit ")
 361                  );
 362        end if;
 363  
 364        if IsSystem(RetValDo) then
 365  
 366           AuditLog.AddElementToLog(
 367                  ElementID    => AuditTypes.SystemFault,
 368                  Severity     => AuditTypes.Warning,
 369                  User         => AuditTypes.NoUser,
 370                  Description  => ConvertRetValToText(RetValDo, "FindObjects ")
 371                  );
 372        end if;
 373  
 374        if IsSystem(RetValFin) then
 375  
 376           AuditLog.AddElementToLog(
 377                  ElementID    => AuditTypes.SystemFault,
 378                  Severity     => AuditTypes.Warning,
 379                  User         => AuditTypes.NoUser,
 380                  Description  => ConvertRetValToText(RetValFin, "FindObjectsFinal ")
 381                  );
 382        end if;
 383  
 384     end DoFind;

+++        Flow analysis of subprogram DoFind performed: no 
           errors found.

 385  
 386  
 387     ------------------------------------------------------------------
 388     -- KeyMatchingIssuer
 389     --
 390     -- Description:
 391     --    Searches for a public key belonging to the issuer in the
 392     --    crypto library.
 393     --    IssuerKey is set to null if a key wasn't found.
 394     --
 395     -- Implementation Notes:
 396     --    If more than one found, a system fault is raised, but the
 397     --    first handle is returned, and the TIS is allowed to continue.
 398     --
 399     ------------------------------------------------------------------
 400     procedure KeyMatchingIssuer(Issuer    : in     CryptoTypes.IssuerT;
 401                                 IssuerKey :    out BasicTypes.Unsigned32T)
 402     --# global in     Interface.Store;
 403     --#        in     Clock.Now;
 404     --#        in     ConfigData.State;
 405     --#        in out AuditLog.State;
 406     --#        in out AuditLog.FileState;
 407     --# derives AuditLog.State,
 408     --#         AuditLog.FileState from Interface.Store,
 409     --#                                 AuditLog.State,
 410     --#                                 AuditLog.FileState,
 411     --#                                 Clock.Now,
 412     --#                                 ConfigData.State,
 413     --#                                 Issuer &
 414     --#         IssuerKey          from Interface.Store,
 415     --#                                 Issuer;
 416     is
 417        IssuerTemplate : Interface.KeyTemplateT;
 418        Handles : Interface.HandleArrayT;
 419  
 420        -- Only expect to find one public key belonging to the issuer
 421        ExpectedCount : constant BasicTypes.Unsigned32T := 1;
 422        ActualCount   : BasicTypes.Unsigned32T := ExpectedCount;
 423  
 424     begin
 425        -- Create a crypto template, with only the Owner attr defined.
 426        IssuerTemplate := Interface.KeyTemplateT'(
 427                             AttrMask  => Interface.OwnerMask or
 428                                          Interface.IsPublicMask,
 429                             Owner     => Issuer,
 430                             KeyID     => 0,
 431                             KeyLength => 0,
 432                             IsPublic  => True);
 433  
 434        DoFind(Template    => IssuerTemplate,
 435               HandleCount => ActualCount,
 436               Handles     => Handles);
 437  
 438        if ActualCount > ExpectedCount then
 439  
 440           -- More than one key matched.
 441           AuditLog.AddElementToLog(
 442                  ElementID    => AuditTypes.SystemFault,
 443                  Severity     => AuditTypes.Warning,
 444                  User         => AuditTypes.NoUser,
 445                  Description  => "Crypto Library Error : Library holds " &
 446                                  "more than one public key for an Issuer."
 447                  );
 448        end if;
 449  
 450        -- If a key wasn't found, the crypto library sets this to the NullKey
 451        -- value.
 452        IssuerKey := Handles(1);
 453  
 454     end KeyMatchingIssuer;

+++        Flow analysis of subprogram KeyMatchingIssuer 
           performed: no errors found.

 455  
 456  
 457     ------------------------------------------------------------------
 458     -- PrivateKey
 459     --
 460     -- Description:
 461     --    Searches for a private key in the crypto library.
 462     --    PrivateKeyHandle is set to null if a key wasn't found.
 463     --
 464     -- Implementation Notes:
 465     --    If more than one found, a system fault is raised, but the
 466     --    first handle is returned, and the TIS is allowed to continue.
 467     --
 468     ------------------------------------------------------------------
 469     procedure PrivateKey(PrivateKeyHandle :    out BasicTypes.Unsigned32T)
 470     --# global in     Interface.Store;
 471     --#        in     Clock.Now;
 472     --#        in     ConfigData.State;
 473     --#        in out AuditLog.State;
 474     --#        in out AuditLog.FileState;
 475     --# derives AuditLog.State,
 476     --#         AuditLog.FileState from Interface.Store,
 477     --#                                 AuditLog.State,
 478     --#                                 AuditLog.FileState,
 479     --#                                 Clock.Now,
 480     --#                                 ConfigData.State &
 481     --#         PrivateKeyHandle   from Interface.Store;
 482     is
 483        PrivateTemplate : Interface.KeyTemplateT;
 484        Handles : Interface.HandleArrayT;
 485  
 486        -- Only expect to find one public key belonging to the issuer
 487        ExpectedCount : constant BasicTypes.Unsigned32T := 1;
 488        ActualCount   : BasicTypes.Unsigned32T := ExpectedCount;
 489  
 490     begin
 491        -- Create a crypto template, with only the IsPublic attr defined.
 492        PrivateTemplate := Interface.KeyTemplateT'(
 493                              AttrMask  => Interface.IsPublicMask,
 494                              Owner     => CryptoTypes.NullIssuer,
 495                              KeyID     => 0,
 496                              KeyLength => 0,
 497                              IsPublic  => False);
 498  
 499        DoFind(Template    => PrivateTemplate,
 500               HandleCount => ActualCount,
 501               Handles     => Handles);
 502  
 503        if ActualCount > ExpectedCount then
 504  
 505           -- More than one key matched.
 506           AuditLog.AddElementToLog(
 507                  ElementID    => AuditTypes.SystemFault,
 508                  Severity     => AuditTypes.Warning,
 509                  User         => AuditTypes.NoUser,
 510                  Description  => "Crypto Library Error : Library holds " &
 511                                  "more than one private key for this TIS."
 512                  );
 513        end if;
 514  
 515        PrivateKeyHandle := Handles(1);
 516  
 517     end PrivateKey;

+++        Flow analysis of subprogram PrivateKey 
           performed: no errors found.

 518  
 519  
 520     ------------------------------------------------------------------
 521     -- Exported Subprograms
 522     --
 523     ------------------------------------------------------------------
 524     ------------------------------------------------------------------
 525     -- Init
 526     --
 527     -- Implementation Notes:
 528     --    None.
 529     --
 530     ------------------------------------------------------------------
 531     procedure Init
 532     --# global in     Interface.Store;
 533     --#        in     Clock.Now;
 534     --#        in     ConfigData.State;
 535     --#        in out AuditLog.State;
 536     --#        in out AuditLog.FileState;
 537     --#           out ThisTISInfo;
 538     --# derives AuditLog.State,
 539     --#         AuditLog.FileState from Interface.Store,
 540     --#                                 AuditLog.State,
 541     --#                                 AuditLog.FileState,
 542     --#                                 Clock.Now,
 543     --#                                 ConfigData.State &
 544     --#         ThisTISInfo        from Interface.Store;
 545     is
 546        RetVal : Interface.ReturnValueT;
 547        ThePrivateKeyH : BasicTypes.Unsigned32T;
 548  
 549        ThePrivateKey : Interface.KeyTemplateT :=
 550                           Interface.KeyTemplateT'(
 551                              AttrMask  => Interface.OwnerMask,
 552                              Owner     => CryptoTypes.NullIssuer,
 553                              KeyID     => 0,
 554                              KeyLength => 0,
 555                              IsPublic  => False);
 556     begin
 557        Interface.Initialize(ReturnValue => RetVal);
 558        if IsSystem(RetVal) then
 559  
 560           AuditLog.AddElementToLog(
 561                  ElementID    => AuditTypes.SystemFault,
 562                  Severity     => AuditTypes.Warning,
 563                  User         => AuditTypes.NoUser,
 564                  Description  => ConvertRetValToText(RetVal, "Initialize")
 565                  );
 566        end if;
 567  
 568        PrivateKey(PrivateKeyHandle => ThePrivateKeyH);
 569  
 570        ThisTISInfo.IsPresent := (ThePrivateKeyH /= NullKey);
 571  
 572        if ThisTISInfo.IsPresent then
 573           Interface.GetAttributeValue(KeyHandle   => ThePrivateKeyH,
 574                                       Template    => ThePrivateKey,
 575                                       ReturnValue => RetVal);
 576  
 577           if RetVal = Interface.Ok then
 578              ThisTISInfo.Owner := ThePrivateKey.Owner;
 579           else
 580              ThisTISInfo.Owner := CryptoTypes.NullIssuer;
 581           end if;
 582        else
 583           ThisTISInfo.Owner := CryptoTypes.NullIssuer;
 584        end if;
 585     end Init;

+++        Flow analysis of subprogram Init performed: no 
           errors found.

 586  
 587  
 588     ------------------------------------------------------------------
 589     -- KeyMatchingIssuerPresent
 590     --
 591     -- Implementation Notes:
 592     --    None.
 593     --
 594     ------------------------------------------------------------------
 595     procedure KeyMatchingIssuerPresent(Issuer    : in     CryptoTypes.IssuerT;
 596                                        IsPresent :    out Boolean)
 597     --# global in     Interface.Store;
 598     --#        in     Clock.Now;
 599     --#        in     ConfigData.State;
 600     --#        in out AuditLog.State;
 601     --#        in out AuditLog.FileState;
 602     --# derives AuditLog.State,
 603     --#         AuditLog.FileState from Interface.Store,
 604     --#                                 AuditLog.State,
 605     --#                                 AuditLog.FileState,
 606     --#                                 Clock.Now,
 607     --#                                 ConfigData.State,
 608     --#                                 Issuer &
 609     --#         IsPresent          from Interface.Store,
 610     --#                                 Issuer;
 611     is
 612        TheIssuerKey : BasicTypes.Unsigned32T;
 613     begin
 614  
 615        KeyMatchingIssuer(Issuer    => Issuer,
 616                          IssuerKey => TheIssuerKey);
 617        IsPresent := (TheIssuerKey /= NullKey);
 618  
 619     end KeyMatchingIssuerPresent;

+++        Flow analysis of subprogram 
           KeyMatchingIssuerPresent performed: no errors found.

 620  
 621  
 622     ------------------------------------------------------------------
 623     -- PrivateKeyPresent
 624     --
 625     -- Implementation Notes:
 626     --    None.
 627     --
 628     ------------------------------------------------------------------
 629     function PrivateKeyPresent return Boolean
 630     --# global ThisTISInfo;
 631     is
 632     begin
 633        return ThisTISInfo.IsPresent;
 634     end PrivateKeyPresent;

+++        Flow analysis of subprogram PrivateKeyPresent 
           performed: no errors found.

 635  
 636  
 637     ------------------------------------------------------------------
 638     -- IssuerIsThisTIS
 639     --
 640     -- Implementation Notes:
 641     --    None
 642     --
 643     ------------------------------------------------------------------
 644     function IssuerIsThisTIS(Issuer : in     CryptoTypes.IssuerT)
 645       return  Boolean
 646     --# global ThisTISInfo;
 647     is
 648        IsTIS : Boolean;
 649     begin
 650        if PrivateKeyPresent then
 651           IsTIS := (Issuer = ThisTISInfo.Owner);
 652        else
 653           IsTIS := False;
 654        end if;
 655        return IsTIS;
 656     end IssuerIsThisTIS;

+++        Flow analysis of subprogram IssuerIsThisTIS 
           performed: no errors found.

 657  
 658  
 659     ------------------------------------------------------------------
 660     -- ThisTIS
 661     --
 662     -- Implementation Notes:
 663     --    None.
 664     --
 665     ------------------------------------------------------------------
 666     function ThisTIS return CryptoTypes.IssuerT
 667     --# global ThisTISInfo;
 668     is
 669     begin
 670        return ThisTISInfo.Owner;
 671     end ThisTIS;

+++        Flow analysis of subprogram ThisTIS performed: 
           no errors found.

 672  
 673  
 674     ------------------------------------------------------------------
 675     -- IsVerifiedBy
 676     --
 677     -- Implementation Notes:
 678     --    None.
 679     --
 680     ------------------------------------------------------------------
 681     procedure  IsVerifiedBy(Mechanism   : in     CryptoTypes.AlgorithmT;
 682                             RawCertData : in     CertTypes.RawDataT;
 683                             Signature   : in     CertTypes.SignatureT;
 684                             TheIssuer   : in     CryptoTypes.IssuerT;
 685                             Verified    :    out Boolean)
 686     --# global in     Interface.Store;
 687     --#        in     Clock.Now;
 688     --#        in     ConfigData.State;
 689     --#        in out AuditLog.State;
 690     --#        in out AuditLog.FileState;
 691     --# derives AuditLog.State,
 692     --#         AuditLog.FileState from Mechanism,
 693     --#                                 RawCertData,
 694     --#                                 Interface.Store,
 695     --#                                 AuditLog.State,
 696     --#                                 AuditLog.FileState,
 697     --#                                 Clock.Now,
 698     --#                                 ConfigData.State,
 699     --#                                 TheIssuer,
 700     --#                                 Signature &
 701     --#         Verified           from Mechanism,
 702     --#                                 RawCertData,
 703     --#                                 Interface.Store,
 704     --#                                 TheIssuer,
 705     --#                                 Signature;
 706     is
 707        TheDigest    : Interface.DigestT;
 708        Digested     : Boolean;
 709        TheIssuerKey : BasicTypes.Unsigned32T;
 710        RetVal       : Interface.ReturnValueT;
 711     begin
 712        Digest(Mechanism   => Mechanism,
 713               RawCertData => RawCertData,
 714               TheDigest   => TheDigest,
 715               Success     => Digested);
 716  
 717        if Digested then
 718           KeyMatchingIssuer(Issuer    => TheIssuer,
 719                             IssuerKey => TheIssuerKey);
 720  
 721           Interface.Verify(Mechanism    => Mechanism,
 722                         KeyHandle    => TheIssuerKey,
 723                         Digest       => TheDigest,
 724                         Signature    => Signature,
 725                         ReturnValue  => RetVal);
 726  
 727           Verified := (RetVal = Interface.Ok);
 728  
 729           if IsSystem(RetVal) then
 730              AuditLog.AddElementToLog(
 731                     ElementID    => AuditTypes.SystemFault,
 732                     Severity     => AuditTypes.Warning,
 733                     User         => AuditTypes.NoUser,
 734                     Description  => ConvertRetValToText(RetVal, "Verify")
 735                     );
 736           end if;
 737  
 738        else
 739           -- Digest has failed -
 740           -- the Digest subprogram adds an entry to the audit log if
 741           -- there is a system fault
 742           Verified := False;
 743        end if;
 744  
 745     end IsVerifiedBy;

+++        Flow analysis of subprogram IsVerifiedBy 
           performed: no errors found.

 746  
 747  
 748  
 749     ------------------------------------------------------------------
 750     -- Sign
 751     --
 752     -- Implementation Notes:
 753     --    None
 754     --
 755     ------------------------------------------------------------------
 756     procedure  Sign(RawCertData : in     CertTypes.RawDataT;
 757                     Signature   :    out CertTypes.SignatureT;
 758                     Signed      :    out Boolean)
 759     --# global in     Interface.Store;
 760     --#        in     Clock.Now;
 761     --#        in     ConfigData.State;
 762     --#        in out AuditLog.State;
 763     --#        in out AuditLog.FileState;
 764     --# derives AuditLog.State,
 765     --#         AuditLog.FileState from RawCertData,
 766     --#                                 Interface.Store,
 767     --#                                 AuditLog.State,
 768     --#                                 AuditLog.FileState,
 769     --#                                 Clock.Now,
 770     --#                                 ConfigData.State &
 771     --#         Signature,
 772     --#         Signed             from RawCertData,
 773     --#                                 Interface.Store;
 774     is
 775        -- This TIS always uses RSA with SHA-1
 776        Mechanism : constant CryptoTypes.AlgorithmT := CryptoTypes.SHA1_RSA;
 777        ThePrivateKeyH : BasicTypes.Unsigned32T;
 778        TheDigest : Interface.DigestT;
 779  
 780        Digested  : Boolean;
 781        RetVal    : Interface.ReturnValueT;
 782     begin
 783        Digest(Mechanism   => Mechanism,
 784               RawCertData => RawCertData,
 785               TheDigest   => TheDigest,
 786               Success     => Digested);
 787  
 788        if Digested then
 789           PrivateKey(PrivateKeyHandle => ThePrivateKeyH);
 790  
 791           Interface.Sign(Mechanism    => Mechanism,
 792                       KeyHandle    => ThePrivateKeyH,
 793                       Digest       => TheDigest,
 794                       Signature    => Signature,
 795                       ReturnValue  => RetVal
 796                       );
 797           Signed := (Retval = Interface.Ok);
 798  
 799           if IsSystem(RetVal) then
 800              AuditLog.AddElementToLog(
 801                     ElementID    => AuditTypes.SystemFault,
 802                     Severity     => AuditTypes.Warning,
 803                     User         => AuditTypes.NoUser,
 804                     Description  => ConvertRetValToText(RetVal, "Sign")
 805                     );
 806           end if;
 807  
 808        else
 809           -- Digest has failed -
 810           -- the Digest subprogram adds an entry to the audit log if
 811           -- there is a system fault
 812           Signed := False;
 813           Signature := CertTypes.SignatureT'(SigData   => CertTypes.SigDataT'(others => ' '),
 814                                              SigLength => 1);
 815        end if;
 816  
 817     end Sign;

+++        Flow analysis of subprogram Sign performed: no 
           errors found.

 818  
 819  
 820     ------------------------------------------------------------------
 821     -- AddKey
 822     --
 823     -- Implementation Notes:
 824     --    None
 825     --
 826     ------------------------------------------------------------------
 827     procedure AddKey(TheOwner : in     CryptoTypes.IssuerT;
 828                      TheKey   : in     CryptoTypes.KeyPartT;
 829                      IsPublic : in     Boolean;
 830                      Added    :    out Boolean)
 831     --# global in     Clock.Now;
 832     --#        in     ConfigData.State;
 833     --#        in out Interface.Store;
 834     --#        in out AuditLog.State;
 835     --#        in out AuditLog.FileState;
 836     --#        in out ThisTISInfo;
 837     --# derives Interface.Store,
 838     --#         ThisTISInfo        from *,
 839     --#                                 Interface.Store,
 840     --#                                 TheOwner,
 841     --#                                 TheKey,
 842     --#                                 IsPublic &
 843     --#         AuditLog.State,
 844     --#         AuditLog.FileState from Interface.Store,
 845     --#                                 AuditLog.State,
 846     --#                                 AuditLog.FileState,
 847     --#                                 Clock.Now,
 848     --#                                 ConfigData.State,
 849     --#                                 TheOwner,
 850     --#                                 TheKey,
 851     --#                                 IsPublic &
 852     --#         Added              from Interface.Store,
 853     --#                                 TheOwner,
 854     --#                                 TheKey,
 855     --#                                 IsPublic;
 856     --# post ((Added and not IsPublic) -> PrivateKeyPresent(ThisTISInfo)) and
 857     --#      (not (Added and not IsPublic) -> PrivateKeyPresent(ThisTISInfo) =
 858     --#                                        PrivateKeyPresent(ThisTISInfo~));
 859     is
 860        TheKeyTemplate : Interface.KeyTemplateT;
 861        RetVal : Interface.ReturnValueT;
 862     begin
 863        -- Create a crypto template.
 864        TheKeyTemplate := Interface.KeyTemplateT'(
 865                             AttrMask  => Interface.FullKeyMask,
 866                             Owner     => TheOwner,
 867                             KeyID     => BasicTypes.Unsigned32T(TheKey.KeyID),
 868                             KeyLength => BasicTypes.Unsigned32T(TheKey.KeyLength),
 869                             IsPublic  => IsPublic);
 870  
 871        Interface.CreateObject(Template     => TheKeyTemplate,
 872                               ReturnValue  => RetVal);
 873  
 874        Added := (RetVal = Interface.Ok);
 875  
 876        if Added and not IsPublic then
 877  
 878           -- Have just added the TIS private key
 879           -- store this TIS' info.
 880           ThisTISInfo := OptionalPrivateKeyT'(
 881                              IsPresent => True,
 882                              Owner     => TheOwner);
 883        end if;
 884  
 885        if IsSystem(RetVal) then
 886           AuditLog.AddElementToLog(
 887                  ElementID    => AuditTypes.SystemFault,
 888                  Severity     => AuditTypes.Warning,
 889                  User         => AuditTypes.NoUser,
 890                  Description  => ConvertRetValToText(RetVal, "AddKey")
 891                  );
 892        end if;
 893     end AddKey;

+++        Flow analysis of subprogram AddKey performed: no 
           errors found.

 894  
 895  
 896     ------------------------------------------------------------------
 897     -- Delete
 898     --
 899     -- Description:
 900     --    Deletes the KeyStore file.
 901     --
 902     -- Traceunit : C.KeyStore.AddKey
 903     -- Traceto   : FD.KeyTypes.UpdateKeyStore
 904     ------------------------------------------------------------------
 905     procedure Delete
 906     --# global in out Interface.Store;
 907     --#           out ThisTISInfo;
 908     --# derives Interface.Store from * &
 909     --#         ThisTISInfo     from ;
 910     --# post not PrivateKeyPresent(ThisTISInfo);
 911     is
 912     begin
 913  
 914        Interface.Delete;
 915  
 916        ThisTISInfo := OptionalPrivateKeyT'(
 917                           IsPresent => False,
 918                           Owner     => CryptoTypes.NullIssuer);
 919     end Delete;

+++        Flow analysis of subprogram Delete performed: no 
           errors found.

 920  
 921  end KeyStore;
130 summarized warning(s), comprising:
     1 hidden part(s)*
   129 use(s) of Ada2005 reserved words
(*Note: the above warnings may affect the validity of the analysis.)



--End of file--------------------------------------------------
