           *******************************************************
                            Listing of SPARK Text
                              Examiner GPL 2011
             Copyright (C) 2011 Altran Praxis Limited, Bath, U.K.
           *******************************************************


                        DATE : 05-SEP-2011 15:33:27.67

Line
   1  ------------------------------------------------------------------
   2  -- Tokeneer ID Station Core Software
   3  --
   4  -- Copyright (2003) United States Government, as represented
   5  -- by the Director, National Security Agency. All rights reserved.
   6  --
   7  -- This material was originally developed by Praxis High Integrity
   8  -- Systems Ltd. under contract to the National Security Agency.
   9  --
  10  -- Modifications to proof annotations by Phil Thornley, April 2009
  11  ------------------------------------------------------------------
  12  
  13  ------------------------------------------------------------------
  14  -- Enclave
  15  --
  16  -- Implementation Notes:
  17  --    None.
  18  --
  19  ------------------------------------------------------------------
  20  with Admin,
  21       AdminToken,
  22       AuditLog,
  23       AuditTypes,
  24       BasicTypes,
  25       Configuration,
  26       Door,
  27       Display,
  28       Enrolment,
  29       File,
  30       Floppy,
  31       KeyStore,
  32       Keyboard,
  33       Latch,
  34       Screen,
  35       UserToken;
  36  
  37  use type Admin.OpAndNullT;
  38  use type BasicTypes.PresenceT;
  39  use type Door.T;
  40  
  41  package body Enclave
  42  --# own State is Status;
  43  is
  44  
  45     ------------------------------------------------------------------
  46     --  Types
  47     ------------------------------------------------------------------
  48     type StatusT is (NotEnrolled,
  49                      WaitingEnrol,
  50                      WaitingEndEnrol,
  51                      EnclaveQuiescent,
  52                      WaitingRemoveAdminTokenFail,
  53                      GotAdminToken,
  54                      WaitingStartAdminOp,
  55                      WaitingFinishAdminOp,
  56                      ShutDown);
  57  
  58     subtype EnrolmentStates is StatusT
  59       range NotEnrolled .. WaitingEndEnrol;
  60  
  61     subtype ActiveEnclaveStates is StatusT
  62       range GotAdminToken .. Shutdown;
  63  
  64     subtype NonQuiescentStates is StatusT
  65       range WaitingRemoveAdminTokenFail .. Shutdown;
  66     ------------------------------------------------------------------
  67     --  State
  68     ------------------------------------------------------------------
  69     Status : StatusT;
  70  
  71  
  72     ------------------------------------------------------------------
  73     --  Private Operations
  74     --
  75     ------------------------------------------------------------------
  76  
  77     ------------------------------------------------------------------
  78     -- PresentAdminHasDeparted
  79     --
  80     -- Description:
  81     --    Returns True exactly when a logged in Administrator leaves.
  82     --
  83     -- Implementation Notes:
  84     --    None.
  85     --
  86     ------------------------------------------------------------------
  87     function PresentAdminHasDeparted (TheAdmin : Admin.T) return Boolean
  88       --# global AdminToken.State;
  89     is
  90        Result : Boolean;
  91     begin
  92        if Admin.IsPresent(TheAdmin) and not AdminToken.IsPresent then
  93           if not Admin.IsDoingOp(TheAdmin) or else
  94              Admin.TheCurrentOp(TheAdmin) /= Admin.ShutdownOp then
  95              Result := True;
  96           else
  97              Result := False;
  98           end if;
  99        else
 100           Result := False;
 101        end if;
 102        return Result;
 103     end PresentAdminHasDeparted;

+++        Flow analysis of subprogram 
           PresentAdminHasDeparted performed: no errors found.

 104  
 105  
 106     ------------------------------------------------------------------
 107     -- AdminTokenHasExpired
 108     --
 109     -- Description:
 110     --    Returns True exactly when a logged on administrator token
 111     --    expires and the administrator is not undertaking an
 112     --    operation.
 113     --
 114     -- Implementation Notes:
 115     --    None.
 116     --
 117     ------------------------------------------------------------------
 118     function AdminTokenHasExpired (TheAdmin : Admin.T) return Boolean
 119       --# global AdminToken.State,
 120       --#        Status,
 121       --#        Clock.CurrentTime;
 122     is
 123     begin
 124        return ( Admin.IsPresent(TheAdmin)
 125                 and AdminToken.IsPresent
 126                 and Status = EnclaveQuiescent
 127                 and not AdminToken.IsCurrent );
 128     end AdminTokenHasExpired;

+++        Flow analysis of subprogram AdminTokenHasExpired 
           performed: no errors found.

 129  
 130  
 131     ------------------------------------------------------------------
 132     -- AdminHasDeparted
 133     --
 134     -- Description:
 135     --    Returns True exactly when the admin token is removed when in
 136     --    a non-quiescent state.
 137     --
 138     -- Implementation Notes:
 139     --    None.
 140     ------------------------------------------------------------------
 141     function AdminHasDeparted return Boolean
 142       --# global AdminToken.State,
 143       --#        Status;
 144     --# return R => (R -> Status in NonQuiescentStates);
 145     is
 146     begin
 147        return ( not AdminToken.IsPresent
 148                 and Status in NonQuiescentStates );
 149     end AdminHasDeparted;

+++        Flow analysis of subprogram AdminHasDeparted 
           performed: no errors found.

 150  
 151  
 152     ------------------------------------------------------------------
 153     -- ReadEnrolmentData
 154     --
 155     -- Description:
 156     --    Attempts to read the enrolment file if a floppy is present
 157     --
 158     -- Implementation Notes:
 159     --    None.
 160     --
 161     -- Traceunit : C.Enclave.ReadEnrolmentData
 162     -- Traceto : FD.Enclave.RequestEnrolment
 163     -- Traceto : FD.Enclave.ReadEnrolmentFloppy
 164     ------------------------------------------------------------------
 165     procedure ReadEnrolmentData
 166     --# global in     ConfigData.State;
 167     --#        in     Clock.Now;
 168     --#        in     Floppy.Input;
 169     --#        in out Status;
 170     --#        in out Screen.State;
 171     --#        in out Display.State;
 172     --#        in out Floppy.State;
 173     --#        in out AuditLog.State;
 174     --#        in out AuditLog.FileState;
 175     --# derives Status,
 176     --#         Screen.State,
 177     --#         Display.State      from *,
 178     --#                                 Floppy.State &
 179     --#         AuditLog.State,
 180     --#         AuditLog.FileState from Screen.State,
 181     --#                                 Display.State,
 182     --#                                 Floppy.State,
 183     --#                                 AuditLog.State,
 184     --#                                 AuditLog.FileState,
 185     --#                                 ConfigData.State,
 186     --#                                 Clock.Now &
 187     --#         Floppy.State       from *,
 188     --#                                 Floppy.Input;
 189     --# pre Status in EnrolmentStates;
 190     --# post Status in EnrolmentStates;
 191     is
 192     begin
 193        if Floppy.IsPresent then
 194  
 195           -- ReadEnrolmentFloppyC actions
 196           Floppy.Read;
 197           Screen.SetMessage(Msg => Screen.ValidatingEnrolmentData);
 198           Display.SetValue(Msg => Display.Blank);
 199  
 200           Status := WaitingEnrol;
 201  
 202        else
 203           -- RequestEnrolmentC actions
 204           Screen.SetMessage(Msg => Screen.InsertEnrolmentData);
 205           Display.SetValue(Msg => Display.Blank);
 206  
 207        end if;
 208     end ReadEnrolmentData;

+++        Flow analysis of subprogram ReadEnrolmentData 
           performed: no errors found.

 209  
 210  
 211     ------------------------------------------------------------------
 212     -- ValidateEnrolmentData
 213     --
 214     -- Description:
 215     --    Attempts to validate the enrolment data
 216     --
 217     -- Implementation Notes:
 218     --    Note that UserEntry.Status is initialized to Quiescent.
 219     --
 220     -- Traceunit : C.Enclave.ValidateEnrolmentData
 221     -- Traceto : FD.Enclave.ValidateEnrolmentDataOK
 222     -- Traceto : FD.Enclave.ValidateEnrolmentDataFail
 223     ------------------------------------------------------------------
 224     procedure ValidateEnrolmentData
 225     --# global in     Floppy.State;
 226     --#        in     ConfigData.State;
 227     --#        in     Clock.Now;
 228     --#        in out Screen.State;
 229     --#        in out Display.State;
 230     --#        in out AuditLog.State;
 231     --#        in out AuditLog.FileState;
 232     --#        in out KeyStore.Store;
 233     --#        in out KeyStore.State;
 234     --#           out Status;
 235     --# derives Status,
 236     --#         KeyStore.Store     from Floppy.State,
 237     --#                                 KeyStore.Store &
 238     --#         Screen.State,
 239     --#         Display.State,
 240     --#         KeyStore.State     from *,
 241     --#                                 Floppy.State,
 242     --#                                 KeyStore.Store &
 243     --#         AuditLog.State,
 244     --#         AuditLog.FileState from Screen.State,
 245     --#                                 Display.State,
 246     --#                                 Floppy.State,
 247     --#                                 AuditLog.State,
 248     --#                                 AuditLog.FileState,
 249     --#                                 ConfigData.State,
 250     --#                                 Clock.Now,
 251     --#                                 KeyStore.Store;
 252     --# pre not KeyStore.PrivateKeyPresent(KeyStore.State);
 253     --# post (Status = EnclaveQuiescent and
 254     --#       KeyStore.PrivateKeyPresent(KeyStore.State)) or
 255     --#      (Status = WaitingEndEnrol and
 256     --#       not KeyStore.PrivateKeyPresent(KeyStore.State));
 257     is
 258        TheCurrentFloppy : File.T;
 259        DataOK : Boolean;
 260        Description : AuditTypes.DescriptionT;
 261     begin
 262        TheCurrentFloppy := Floppy.CurrentFloppy;
 263  
 264        --# accept F, 10, TheCurrentFloppy, "Ineffective assignment expected here";
 265        Enrolment.Validate(TheFile     => TheCurrentFloppy,
 266                           DataOK      => DataOK,
 267                           Description => Description);
 268        --# end accept;
 269  
 270        if DataOK then
 271  
 272           -- ValidateEnrolmentDataOK actions
 273           Screen.SetMessage(Msg => Screen.WelcomeAdmin);
 274           Display.SetValue(Msg => Display.Welcome);
 275           Status := EnclaveQuiescent;
 276  
 277           AuditLog.AddElementToLog
 278             ( ElementID   => AuditTypes.EnrolmentComplete,
 279               Severity    => AuditTypes.Information,
 280               User        => AuditTypes.NoUser,
 281               Description => AuditTypes.NoDescription
 282               );
 283  
 284        else
 285           -- ValidateEnrolmentDataFail actions
 286           Screen.SetMessage(Msg => Screen.EnrolmentFailed);
 287           Display.SetValue(Msg => Display.Blank);
 288           Status := WaitingEndEnrol;
 289  
 290           AuditLog.AddElementToLog
 291             ( ElementID   => AuditTypes.EnrolmentFailed,
 292               Severity    => AuditTypes.Warning,
 293               User        => AuditTypes.NoUser,
 294               Description => Description
 295               );
 296  
 297        end if;
 298     end ValidateEnrolmentData;

+++        Flow analysis of subprogram 
           ValidateEnrolmentData performed: no errors found.

 299  
 300  
 301     ------------------------------------------------------------------
 302     -- CompleteFailedEnrolment
 303     --
 304     -- Description:
 305     --    Performes actions when the enclave status is WaitingEndEnrol
 306     --
 307     -- Implementation Notes:
 308     --    None
 309     --
 310     -- Traceunit : C.Enclave.CompleteFailedEnrolment
 311     -- Traceto : FD.Enclave.FailedEnrolFloppyRemoved
 312     -- Traceto : FD.Enclave.WaitingFloppyRemoval
 313     ------------------------------------------------------------------
 314     procedure CompleteFailedEnrolment
 315     --# global in     Floppy.State;
 316     --#        in     ConfigData.State;
 317     --#        in     Clock.Now;
 318     --#        in out Status;
 319     --#        in out Screen.State;
 320     --#        in out Display.State;
 321     --#        in out AuditLog.State;
 322     --#        in out AuditLog.FileState;
 323     --# derives Status,
 324     --#         Screen.State,
 325     --#         Display.State      from *,
 326     --#                                 Floppy.State &
 327     --#         AuditLog.State,
 328     --#         AuditLog.FileState from Screen.State,
 329     --#                                 Display.State,
 330     --#                                 Floppy.State,
 331     --#                                 AuditLog.State,
 332     --#                                 AuditLog.FileState,
 333     --#                                 ConfigData.State,
 334     --#                                 Clock.Now;
 335     --# pre Status = WaitingEndEnrol;
 336     --# post Status = WaitingEndEnrol or Status = NotEnrolled;
 337     is
 338     begin
 339        if not Floppy.IsPresent then
 340  
 341           -- FailedEnrolFloppyRemoved actions
 342           Screen.SetMessage(Msg => Screen.InsertEnrolmentData);
 343           Display.SetValue(Msg => Display.Blank);
 344  
 345           Status := NotEnrolled;
 346  
 347        end if; -- else WaitingFloppyRemoval (no actions)
 348  
 349     end CompleteFailedEnrolment;

+++        Flow analysis of subprogram 
           CompleteFailedEnrolment performed: no errors found.

 350  
 351  
 352     ------------------------------------------------------------------
 353     -- AdminTokenTear
 354     --
 355     -- Description:
 356     --    Handles an admin token tear.
 357     --
 358     -- Implementation Notes:
 359     --    Setting of the screen message is postponed to TIS since
 360     --    we cannot determine whether there is a user entry in progress
 361     --    from here.
 362     --
 363     ------------------------------------------------------------------
 364     procedure AdminTokenTear
 365     --# global in out AdminToken.State;
 366     --# derives AdminToken.State   from * ;
 367  --    --# post not AdminToken.prf_isGood(AdminToken.State) and
 368  --    --#      not AdminToken.prf_authCertValid(AdminToken.State) and
 369  --    --#      not ( AdminToken.TheAuthCertRole(AdminToken.State)
 370  --    --#               in PrivTypes.AdminPrivilegeT );
 371     is
 372     begin
 373  
 374        AdminToken.Clear;
 375  
 376     end AdminTokenTear;

+++        Flow analysis of subprogram AdminTokenTear 
           performed: no errors found.

 377  
 378  
 379     ------------------------------------------------------------------
 380     -- BadAdminTokenTear
 381     --
 382     -- Description:
 383     --    Handles a bad admin token tear.
 384     --
 385     -- Implementation Notes:
 386     --    Note that we can deduce the screen message since BadAdminTokenTears
 387     --    only occur when the Admin is active and hence user entry is not
 388     --    in progress.
 389     --
 390     -- Traceunit : C.Enclave.BadAdminTokenTear
 391     -- Traceto : FD.Enclave.LoginAborted
 392     -- Traceto : FD.Enclave.BadAdminLogout
 393     ------------------------------------------------------------------
 394     procedure BadAdminTokenTear
 395     --# global in     ConfigData.State;
 396     --#        in     Clock.Now;
 397     --#        in out AdminToken.State;
 398     --#        in out AuditLog.State;
 399     --#        in out AuditLog.FileState;
 400     --#           out Status;
 401     --# derives AdminToken.State   from * &
 402     --#         AuditLog.State,
 403     --#         AuditLog.FileState from AdminToken.State,
 404     --#                                 AuditLog.State,
 405     --#                                 AuditLog.FileState,
 406     --#                                 ConfigData.State,
 407     --#                                 Clock.Now &
 408     --#         Status             from ;
 409     --# post Status = EnclaveQuiescent;
 410  --    --#      not AdminToken.prf_isGood(AdminToken.State) and
 411  --    --#      not AdminToken.prf_authCertValid(AdminToken.State) and
 412  --    --#      not ( AdminToken.TheAuthCertRole(AdminToken.State)
 413  --    --#               in PrivTypes.AdminPrivilegeT );
 414     is
 415     begin
 416  
 417        AuditLog.AddElementToLog
 418          ( ElementID   => AuditTypes.AdminTokenRemoved,
 419            Severity    => AuditTypes.Warning,
 420            User        => AdminToken.ExtractUser,
 421            Description => AuditTypes.NoDescription
 422            );
 423  
 424        Status := enclaveQuiescent;
 425        AdminTokenTear;
 426  
 427     end BadAdminTokenTear;

+++        Flow analysis of subprogram BadAdminTokenTear 
           performed: no errors found.

 428  
 429  
 430     ------------------------------------------------------------------
 431     -- ValidateAdminToken
 432     --
 433     -- Description:
 434     --    Reads and validates the administrator's token.
 435     --    Performs all actions when Status = GotAdminToken
 436     --
 437     -- Implementation Notes:
 438     --    Since it is expensive to read all the certificates from the
 439     --    token they are only read if required. This means that the
 440     --    reading of the certificates from the token is postponed until
 441     --    this operation.
 442     --
 443     -- Traceunit : C.Enclave.ValidateAdminToken
 444     -- Traceto : FD.Enclave.GetPresentAdminToken
 445  
 446  
 447     -- Traceto : FD.Enclave.ValidateAdminTokenOK
 448     -- Traceto : FD.Enclave.ValidateAdminTokenFail
 449     -- Traceto : FD.Enclave.LoginAborted
 450     ------------------------------------------------------------------
 451     procedure ValidateAdminToken(TheAdmin : in out Admin.T)
 452     --# global in     Clock.CurrentTime;
 453     --#        in     ConfigData.State;
 454     --#        in     Clock.Now;
 455     --#        in     KeyStore.Store;
 456     --#        in     KeyStore.State;
 457     --#        in     AdminToken.Input;
 458     --#        in out AdminToken.State;
 459     --#        in out Screen.State;
 460     --#        in out AuditLog.State;
 461     --#        in out AuditLog.FileState;
 462     --#        in out AdminToken.Status;
 463     --#           out Status;
 464     --# derives AdminToken.State,
 465     --#         Screen.State,
 466     --#         TheAdmin           from *,
 467     --#                                 AdminToken.State,
 468     --#                                 Clock.CurrentTime,
 469     --#                                 KeyStore.Store,
 470     --#                                 KeyStore.State,
 471     --#                                 AdminToken.Status,
 472     --#                                 AdminToken.Input &
 473     --#         AuditLog.State,
 474     --#         AuditLog.FileState from AdminToken.State,
 475     --#                                 Clock.CurrentTime,
 476     --#                                 Screen.State,
 477     --#                                 AuditLog.State,
 478     --#                                 AuditLog.FileState,
 479     --#                                 ConfigData.State,
 480     --#                                 Clock.Now,
 481     --#                                 KeyStore.Store,
 482     --#                                 KeyStore.State,
 483     --#                                 AdminToken.Status,
 484     --#                                 AdminToken.Input &
 485     --#         Status             from AdminToken.State,
 486     --#                                 Clock.CurrentTime,
 487     --#                                 KeyStore.Store,
 488     --#                                 KeyStore.State,
 489     --#                                 AdminToken.Status,
 490     --#                                 AdminToken.Input &
 491     --#         AdminToken.Status  from *,
 492     --#                                 AdminToken.State;
 493     --#
 494     --# pre not Admin.IsPresent(TheAdmin) and
 495     --#     not Admin.IsDoingOp(TheAdmin) and
 496     --#
 497     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 498     --#           ( AdminToken.prf_isGood(AdminToken.State) and
 499     --#             AdminToken.prf_authCertValid(AdminToken.State) and
 500     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
 501     --#
 502     --#      ( ( Admin.IsDoingOp(TheAdmin) and
 503     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
 504     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
 505     --#
 506     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 507     --#           ( ( Admin.IsDoingOp(TheAdmin) and
 508     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
 509     --#             not Admin.IsDoingOp(TheAdmin) ));
 510     --#
 511     --#
 512     --# post ( Status = EnclaveQuiescent or
 513     --#        Status = WaitingRemoveAdminTokenFail ) and
 514     --#
 515     --#      ( Status = WaitingRemoveAdminTokenFail -> not Admin.IsPresent(TheAdmin) ) and
 516     --#
 517     --#      not Admin.IsDoingOp(TheAdmin) and
 518     --#
 519     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 520     --#           ( AdminToken.prf_isGood(AdminToken.State) and
 521     --#             AdminToken.prf_authCertValid(AdminToken.State) and
 522     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
 523     --#
 524     --#      ( ( Admin.IsDoingOp(TheAdmin) and
 525     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
 526     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
 527     --#
 528     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 529     --#           ( ( Admin.IsDoingOp(TheAdmin) and
 530     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
 531     --#             not Admin.IsDoingOp(TheAdmin) ));
 532     is
 533  
 534       TokenOK : Boolean;
 535  
 536       Description : AuditTypes.DescriptionT;
 537     begin
 538  
 539        if not AdminToken.IsPresent then
 540  
 541           -- LoginAbortedC actions
 542           BadAdminTokenTear;
 543  
 544           --# check Admin.prf_rolePresent(TheAdmin) /= PrivTypes.Guard;
 545  
 546        else
 547  
 548           AdminToken.ReadAndCheck (Description => Description,
 549                                    TokenOK     => TokenOk);
 550  
 551           -- GetPresentAdminTokenC postponed actions
 552           AuditLog.AddElementToLog
 553             ( ElementID   => AuditTypes.AdminTokenPresent,
 554               Severity    => AuditTypes.Information,
 555               User        => AdminToken.ExtractUser,
 556               Description => AuditTypes.NoDescription
 557               );
 558  
 559           if TokenOK then
 560  
 561              -- ValidateAdminTokenOKC actions
 562              AuditLog.AddElementToLog
 563                ( ElementID   => AuditTypes.AdminTokenValid,
 564                  Severity    => AuditTypes.Information,
 565                  User        => AdminToken.ExtractUser,
 566                  Description => AuditTypes.NoDescription
 567                  );
 568  
 569              Screen.SetMessage (Msg => Screen.RequestAdminOp);
 570              Status := EnclaveQuiescent;
 571  
 572              Admin.Logon (TheAdmin => TheAdmin,
 573                           Role     => AdminToken.GetRole);
 574  
 575              --# check AdminToken.GetRole (AdminToken.State) = PrivTypes.Guard ->
 576              --#         AdminToken.TheAuthCertRole (AdminToken.State) = PrivTypes.Guard;
 577  
 578           else
 579  
 580              -- ValidateAdminTokenFailC actions
 581  
 582              AuditLog.AddElementToLog
 583                ( ElementID   => AuditTypes.AdminTokenInvalid,
 584                  Severity    => AuditTypes.Warning,
 585                  User        => AdminToken.ExtractUser,
 586                  Description => Description
 587                  );
 588  
 589              Screen.SetMessage (Msg => Screen.RemoveAdminToken);
 590              Status := WaitingRemoveAdminTokenFail;
 591  
 592  
 593              --# check Admin.prf_rolePresent(TheAdmin) /= PrivTypes.Guard;
 594  
 595           end if;
 596        end if;
 597     end ValidateAdminToken;

+++        Flow analysis of subprogram ValidateAdminToken 
           performed: no errors found.

 598  
 599  
 600     ------------------------------------------------------------------
 601     -- CompleteFailedAdminLogon
 602     --
 603     -- Description:
 604     --    Handles the removal of the administrator's token after a
 605     --    failed logon.
 606     --
 607     -- Implementation Notes:
 608     --    None
 609     --
 610     -- Traceunit : C.Enclave.CompleteFailedAdminLogon
 611     -- Traceto: FD.Enclave.FailedAdminTokenRemoved
 612     ------------------------------------------------------------------
 613     procedure CompleteFailedAdminLogon
 614     --# global in     ConfigData.State;
 615     --#        in     Clock.Now;
 616     --#        in out AdminToken.State;
 617     --#        in out Screen.State;
 618     --#        in out AuditLog.State;
 619     --#        in out AuditLog.FileState;
 620     --#           out Status;
 621     --# derives AdminToken.State,
 622     --#         Screen.State       from * &
 623     --#         AuditLog.State,
 624     --#         AuditLog.FileState from AdminToken.State,
 625     --#                                 Screen.State,
 626     --#                                 AuditLog.State,
 627     --#                                 AuditLog.FileState,
 628     --#                                 ConfigData.State,
 629     --#                                 Clock.Now &
 630     --#         Status             from ;
 631     --# post Status = EnclaveQuiescent;
 632  --    --#      not AdminToken.prf_isGood(AdminToken.State) and
 633  --    --#      not AdminToken.prf_authCertValid(AdminToken.State) and
 634  --    --#      AdminToken.TheAuthCertRole(AdminToken.State) /= PrivTypes.Guard;
 635     is
 636  
 637     begin
 638  
 639        AuditLog.AddElementToLog
 640          ( ElementID   => AuditTypes.AdminTokenRemoved,
 641            Severity    => AuditTypes.Information,
 642            User        => AdminToken.ExtractUser,
 643            Description => AuditTypes.NoDescription
 644            );
 645  
 646        Status := EnclaveQuiescent;
 647        Screen.SetMessage(Msg => Screen.WelcomeAdmin);
 648  
 649        AdminToken.Clear;
 650  
 651     end CompleteFailedAdminLogon;

+++        Flow analysis of subprogram 
           CompleteFailedAdminLogon performed: no errors found.

 652  
 653  
 654     ------------------------------------------------------------------
 655     -- ArchiveLogOp
 656     --
 657     -- Description:
 658     --    Performs the "archive log" operation
 659     --
 660     -- Implementation Notes:
 661     --    None
 662     --
 663     -- Traceunit : C.Enclave.ArchiveLogOp
 664     -- Traceto: FD.Enclave.TISArchiveLogOp
 665     -- Traceto: FD.Enclave.StartArchiveLogOK
 666     -- Traceto: FD.Enclave.StartArchiveLogWaitingFloppy
 667     -- Traceto: FD.Enclave.FinishArchiveLogOK
 668     -- Traceto: FD.Enclave.FinishArchiveLogNoFloppy
 669     -- Traceto: FD.Enclave.FinishArchiveLogBadMatch
 670     ------------------------------------------------------------------
 671     procedure ArchiveLogOp(TheAdmin : in out Admin.T)
 672     --# global in     AdminToken.State;
 673     --#        in     Clock.Now;
 674     --#           out Floppy.Output;
 675     --#        in out Status;
 676     --#        in out Screen.State;
 677     --#        in out Floppy.State;
 678     --#        in out AuditLog.State;
 679     --#        in out AuditLog.FileState;
 680     --#        in     ConfigData.State;
 681     --#        in out Floppy.WrittenState;
 682     --#        in     Floppy.Input;
 683     --# derives Status               from *, Floppy.State &
 684     --#         Screen.State         from *,
 685     --#                                   Status,
 686     --#                                   Floppy.State,
 687     --#                                   Floppy.Input,
 688     --#                                   Floppy.WrittenState &
 689     --#         AuditLog.State,
 690     --#         AuditLog.FileState   from AdminToken.State,
 691     --#                                   Screen.State, Status,
 692     --#                                   Floppy.State,
 693     --#                                   Floppy.WrittenState,
 694     --#                                   Floppy.Input,
 695     --#                                   AuditLog.State,
 696     --#                                   AuditLog.FileState,
 697     --#                                   ConfigData.State,
 698     --#                                   Clock.Now &
 699     --#         Floppy.Output        from Floppy.State, Status,
 700     --#                                   AuditLog.State,
 701     --#                                   AuditLog.FileState &
 702     --#         Floppy.State         from *, Status &
 703     --#         Floppy.WrittenState  from *, Floppy.State, Status,
 704     --#                                   AuditLog.State,
 705     --#                                   AuditLog.FileState &
 706     --#         TheAdmin             from *, Status ;
 707     --#
 708     --# pre  ( Status = WaitingStartAdminOp or
 709     --#        Status = WaitingFinishAdminOp ) and
 710     --#
 711     --#      Admin.IsPresent(TheAdmin) and
 712     --#      Admin.IsDoingOp(TheAdmin) and
 713     --#      Admin.TheCurrentOp(TheAdmin) = Admin.ArchiveLog and
 714     --#
 715     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 716     --#           ( AdminToken.prf_isGood(AdminToken.State) and
 717     --#             AdminToken.prf_authCertValid(AdminToken.State) and
 718     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
 719     --#
 720     --#      ( ( Admin.IsDoingOp(TheAdmin) and
 721     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
 722     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
 723     --#
 724     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 725     --#           ( ( Admin.IsDoingOp(TheAdmin) and
 726     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
 727     --#             not Admin.IsDoingOp(TheAdmin) ));
 728     --#
 729     --#
 730     --# post ( Status = WaitingStartAdminOp or
 731     --#        Status = WaitingFinishAdminOp or
 732     --#        Status = EnclaveQuiescent ) and
 733     --#
 734     --#      Admin.IsPresent(TheAdmin) and
 735     --#
 736     --#      ( ( Status = WaitingStartAdminOp or
 737     --#          Status = WaitingFinishAdminOp ) ->
 738     --#        ( Admin.IsDoingOp(TheAdmin) and
 739     --#          Admin.IsPresent(TheAdmin) and
 740     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ArchiveLog ) ) and
 741     --#
 742     --#      ( Status = EnclaveQuiescent ->
 743     --#        not Admin.IsDoingOp(TheAdmin) ) and
 744     --#
 745     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 746     --#           ( AdminToken.prf_isGood(AdminToken.State) and
 747     --#             AdminToken.prf_authCertValid(AdminToken.State) and
 748     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
 749     --#
 750     --#      ( ( Admin.IsDoingOp(TheAdmin) and
 751     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
 752     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
 753     --#
 754     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
 755     --#           ( ( Admin.IsDoingOp(TheAdmin) and
 756     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
 757     --#             not Admin.IsDoingOp(TheAdmin) )) and
 758     --#
 759     --#      Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~);
 760     is
 761  
 762        ------------------------------------------------------------------
 763        -- StartArchiveLog
 764        --
 765        -- Description:
 766        --    Starts the "archive log" operation
 767        --
 768        -- Implementation Notes:
 769        --    None
 770        --
 771        -- Traceunit : C.Enclave.ArchiveLogOp.StartArchiveLog
 772        -- Traceto: FD.Enclave.StartArchiveLogOK
 773        -- Traceto: FD.Enclave.StartArchiveLogWaitingFloppy
 774        ------------------------------------------------------------------
 775        procedure StartArchiveLog
 776        --# global in     AdminToken.State;
 777        --#        in     Clock.Now;
 778        --#           out Floppy.Output;
 779        --#        in out Status;
 780        --#        in out Screen.State;
 781        --#        in out Floppy.State;
 782        --#        in out AuditLog.State;
 783        --#        in out AuditLog.FileState;
 784        --#        in     ConfigData.State;
 785        --#        in out Floppy.WrittenState;
 786        --# derives Status               from *, Floppy.State &
 787        --#         Screen.State         from *,
 788        --#                                   Floppy.State &
 789        --#         AuditLog.State,
 790        --#         AuditLog.FileState   from AdminToken.State,
 791        --#                                   Screen.State,
 792        --#                                   Floppy.State,
 793        --#                                   AuditLog.State,
 794        --#                                   AuditLog.FileState,
 795        --#                                   ConfigData.State,
 796        --#                                   Clock.Now &
 797        --#         Floppy.State         from * &
 798        --#         Floppy.Output        from Floppy.State,
 799        --#                                   AuditLog.State,
 800        --#                                   AuditLog.FileState &
 801        --#         Floppy.WrittenState  from *, Floppy.State,
 802        --#                                   AuditLog.State,
 803        --#                                   AuditLog.FileState;
 804        --# pre Status = WaitingStartAdminOp;
 805        --# post Status = WaitingStartAdminOp or
 806        --#      Status = WaitingFinishAdminOp;
 807        is
 808           TheLog : File.T;
 809        begin
 810           if Floppy.IsPresent then
 811  
 812              -- StartArchiveLogOK actions
 813              AuditLog.ArchiveLog(User    => AdminToken.ExtractUser,
 814                                  Archive => TheLog);
 815              Screen.SetMessage(Msg => Screen.DoingOp);
 816              Status := WaitingFinishAdminOp;
 817  
 818              -- UpdateFloppy
 819              Floppy.Write(TheFile => TheLog);
 820           else
 821              -- StartArchiveLogWaitingFloppy actions
 822              Screen.SetMessage(Msg => Screen.InsertBlankFloppy);
 823           end if;
 824        end StartArchiveLog;

+++        Flow analysis of subprogram StartArchiveLog 
           performed: no errors found.

 825  
 826  
 827        ------------------------------------------------------------------
 828        -- FinishArchiveLog
 829        --
 830        -- Description:
 831        --    Finishes the "archive log" operation
 832        --
 833        -- Implementation Notes:
 834        --    None
 835        --
 836        -- Traceunit : C.Enclave.ArchiveLogOp.FinishArchiveLog
 837        -- Traceto: FD.Enclave.FinishArchiveLogOK
 838        -- Traceto: FD.Enclave.FinishArchiveLogNoFloppy
 839        -- Traceto: FD.Enclave.FinishArchiveLogBadMatch
 840        ------------------------------------------------------------------
 841        procedure FinishArchiveLog
 842        --# global in     AdminToken.State;
 843        --#        in out TheAdmin;
 844        --#        in     Clock.Now;
 845        --#        in     Floppy.Input;
 846        --#        in out Floppy.WrittenState;
 847        --#           out Status;
 848        --#        in out Screen.State;
 849        --#        in out Floppy.State;
 850        --#        in out AuditLog.State;
 851        --#        in out AuditLog.FileState;
 852        --#        in     ConfigData.State;
 853        --# derives Status from &
 854        --#         Screen.State         from * ,
 855        --#                                   Floppy.State,
 856        --#                                   Floppy.WrittenState,
 857        --#                                   Floppy.Input &
 858        --#         AuditLog.State,
 859        --#         AuditLog.FileState   from AdminToken.State,
 860        --#                                   Screen.State,
 861        --#                                   Floppy.State,
 862        --#                                   Floppy.WrittenState,
 863        --#                                   Floppy.Input,
 864        --#                                   AuditLog.State,
 865        --#                                   AuditLog.FileState,
 866        --#                                   ConfigData.State,
 867        --#                                   Clock.Now &
 868        --#         Floppy.State         from * &
 869        --#         Floppy.WrittenState  from Floppy.State,
 870        --#                                   Floppy.WrittenState &
 871        --#         TheAdmin             from * ;
 872        --# pre Admin.IsPresent(TheAdmin);
 873        --# post Status = EnclaveQuiescent and
 874        --#      Admin.IsPresent(TheAdmin) and
 875        --#      not Admin.IsDoingOp(TheAdmin) and
 876        --#      Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~);
 877        is
 878           WriteOK : Boolean;
 879        begin
 880           if Floppy.IsPresent then
 881  
 882              Floppy.Read;
 883              Floppy.CheckWrite(WriteOK => WriteOK);
 884  
 885              if WriteOK then
 886                 -- FinishArchiveLogOK unique actions
 887                 AuditLog.ClearLogEntries (User => AdminToken.ExtractUser);
 888                 Screen.SetMessage(Msg => Screen.RequestAdminOp);
 889              else
 890                 -- FinishArchiveLogBadMatch unique actions
 891                 AuditLog.CancelArchive;
 892  
 893                 AuditLog.AddElementToLog
 894                   ( ElementID   => AuditTypes.ArchiveCheckFailed,
 895                     Severity    => AuditTypes.Warning,
 896                     User        => AdminToken.ExtractUser,
 897                     Description => "Archive Cancelled - Floppy has bad data"
 898                     );
 899  
 900                 Screen.SetMessage(Msg => Screen.ArchiveFailed);
 901  
 902              end if;
 903  
 904           else
 905              -- FinishArchiveLogNoFloppy unique actions
 906              AuditLog.CancelArchive;
 907  
 908              AuditLog.AddElementToLog
 909                ( ElementID   => AuditTypes.ArchiveCheckFailed,
 910                  Severity    => AuditTypes.Warning,
 911                  User        => AdminToken.ExtractUser,
 912                  Description => "Archive Cancelled - Floppy has been removed"
 913                  );
 914  
 915              Screen.SetMessage(Msg => Screen.ArchiveFailed);
 916           end if;
 917  
 918           -- FinishArchiveLog common actions
 919  
 920           Status := EnclaveQuiescent;
 921  
 922           Admin.FinishOp(TheAdmin => TheAdmin);
 923        end FinishArchiveLog;

+++        Flow analysis of subprogram FinishArchiveLog 
           performed: no errors found.

 924  
 925  
 926     ------------------------
 927     -- begin ArchiveLogOp --
 928     ------------------------
 929     begin
 930        if Status = WaitingStartAdminOp then
 931           StartArchiveLog;
 932        else
 933           FinishArchiveLog;
 934        end if;
 935     end ArchiveLogOp;

+++        Flow analysis of subprogram ArchiveLogOp 
           performed: no errors found.

 936  
 937  
 938     ------------------------------------------------------------------
 939     -- UpdateConfigDataOp
 940     --
 941     -- Description:
 942     --    Performs the "update config data" operation
 943     --    May raise SystemFault.
 944     --
 945     -- Implementation Notes:
 946     --    The Configuration utility layer performs the audit actions
 947     --
 948     -- Traceunit : C.Enclave.UpdateConfigDataOp
 949     -- Traceto: FD.Enclave.TISUpdateConfigDataOp
 950     -- Traceto: FD.Enclave.StartUpdateConfigDataOK
 951     -- Traceto: FD.Enclave.StartUpdateConfigWaitingFloppy
 952     -- Traceto: FD.Enclave.FinishUpdateConfigDataOK
 953     -- Traceto: FD.Enclave.FinishUpdateConfigDataFail
 954     ------------------------------------------------------------------
 955     procedure UpdateConfigDataOp(TheAdmin : in out Admin.T)
 956     --# global in     AdminToken.State;
 957     --#        in     Clock.Now;
 958     --#        in     Floppy.Input;
 959     --#        in out Status;
 960     --#        in out Screen.State;
 961     --#        in out Floppy.State;
 962     --#        in out AuditLog.State;
 963     --#        in out AuditLog.FileState;
 964     --#        in out ConfigData.State;
 965     --#        in out ConfigData.FileState;
 966     --# derives Status,
 967     --#         Screen.State,
 968     --#         ConfigData.FileState from *,
 969     --#                                   Status,
 970     --#                                   Floppy.State &
 971     --#         AuditLog.State,
 972     --#         AuditLog.FileState   from AdminToken.State,
 973     --#                                   Status,
 974     --#                                   Screen.State,
 975     --#                                   Floppy.State,
 976     --#                                   AuditLog.State,
 977     --#                                   AuditLog.FileState,
 978     --#                                   ConfigData.State,
 979     --#                                   Clock.Now,
 980     --#                                   ConfigData.FileState &
 981     --#         Floppy.State         from *,
 982     --#                                   Status,
 983     --#                                   Floppy.Input &
 984     --#         ConfigData.State     from *,
 985     --#                                   Status,
 986     --#                                   Floppy.State &
 987     --#         TheAdmin             from *,
 988     --#                                   Status;
 989     --# pre  ( Status = WaitingStartAdminOp or
 990     --#        Status = WaitingFinishAdminOp ) and
 991     --#      Admin.IsPresent(TheAdmin) and
 992     --#      Admin.IsDoingOp(TheAdmin) and
 993     --#      Admin.TheCurrentOp(TheAdmin) = Admin.UpdateConfigData;
 994     --# post ( Status = WaitingStartAdminOp or
 995     --#        Status = WaitingFinishAdminOp or
 996     --#        Status = EnclaveQuiescent ) and
 997     --#      Admin.IsPresent(TheAdmin) and
 998     --#      ( ( Status = WaitingStartAdminOp or
 999     --#          Status = WaitingFinishAdminOp ) ->
1000     --#        ( Admin.IsDoingOp(TheAdmin) and
1001     --#          Admin.IsPresent(TheAdmin) and
1002     --#          Admin.TheCurrentOp(TheAdmin) = Admin.UpdateConfigData ) ) and
1003     --#
1004     --#      ( Status = EnclaveQuiescent ->
1005     --#        not Admin.IsDoingOp(TheAdmin) ) and
1006     --#
1007     --#      Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~);
1008     is
1009        TheCurrentFloppy : File.T;
1010        ConfigDataOK     : Boolean;
1011     begin
1012        if Status = WaitingStartAdminOp then
1013  
1014           -- StartUpdateConfigDataC
1015           if Floppy.IsPresent then
1016  
1017              -- StartUpdateConfigDataOK actions
1018              Floppy.Read;
1019              Screen.SetMessage(Msg => Screen.DoingOp);
1020              Status := WaitingFinishAdminOp;
1021           else
1022              -- StartUpdateConfigWaitingFloppy actions
1023              Screen.SetMessage(Msg => Screen.InsertConfigData);
1024           end if;
1025  
1026        else
1027           -- FinishUpdateConfigDataC
1028           TheCurrentFloppy := Floppy.CurrentFloppy;
1029  
1030           --# accept F, 10, TheCurrentFloppy, "Ineffective assignment expected here";
1031           Configuration.UpdateData
1032             ( TheFile   => TheCurrentFloppy,
1033               DataValid => ConfigDataOK );
1034           --# end accept;
1035  
1036           if ConfigDataOK then
1037              Screen.SetMessage(Msg => Screen.RequestAdminOp);
1038           else
1039              Screen.SetMessage(Msg => Screen.InvalidData);
1040           end if;
1041           Status := EnclaveQuiescent;
1042  
1043           Admin.FinishOp(TheAdmin => TheAdmin);
1044        end if;
1045  
1046     end UpdateConfigDataOp;

+++        Flow analysis of subprogram UpdateConfigDataOp 
           performed: no errors found.

1047  
1048  
1049     ------------------------------------------------------------------
1050     -- OverrideDoorLockOp
1051     --
1052     -- Description:
1053     --    Performs the "override door lock" operation
1054     --
1055     -- Implementation Notes:
1056     --    None
1057     --
1058     -- Traceunit : C.Enclave.OverrideDoorLockOp
1059     -- Traceto: FD.Enclave.TISUnlockDoorOp
1060     -- Traceto: FD.Enclave.OverrideDoorLockOK
1061     ------------------------------------------------------------------
1062     procedure OverrideDoorLockOp(TheAdmin : in out Admin.T)
1063     --# global in     AdminToken.State;
1064     --#        in     Clock.CurrentTime;
1065     --#        in     ConfigData.State;
1066     --#        in     Clock.Now;
1067     --#        in out Screen.State;
1068     --#        in out Display.State;
1069     --#        in out AuditLog.State;
1070     --#        in out AuditLog.FileState;
1071     --#        in out Door.State;
1072     --#        in out Latch.State;
1073     --#           out Status;
1074     --# derives Screen.State,
1075     --#         Display.State,
1076     --#         TheAdmin           from * &
1077     --#         AuditLog.State,
1078     --#         AuditLog.FileState from AdminToken.State,
1079     --#                                 Clock.CurrentTime,
1080     --#                                 Screen.State,
1081     --#                                 Display.State,
1082     --#                                 AuditLog.State,
1083     --#                                 AuditLog.FileState,
1084     --#                                 ConfigData.State,
1085     --#                                 Clock.Now,
1086     --#                                 Door.State,
1087     --#                                 Latch.State &
1088     --#         Door.State,
1089     --#         Latch.State        from *,
1090     --#                                 Clock.CurrentTime,
1091     --#                                 ConfigData.State,
1092     --#                                 Latch.State &
1093     --#         Status             from ;
1094     --# pre  Admin.IsDoingOp(TheAdmin) and
1095     --#      Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock and
1096     --#      Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard and
1097     --#
1098     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1099     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1100     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1101     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1102     --#
1103     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1104     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1105     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1106     --#
1107     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1108     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1109     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1110     --#             not Admin.IsDoingOp(TheAdmin) ) );
1111     --#
1112     --# post Status = EnclaveQuiescent and
1113     --#      --------------------------------------------------------
1114     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1115     --#      --====================================================--
1116     --#      -- After each call to OverrideDoorLockOp, the         --
1117     --#      -- security property holds.                           --
1118     --#      --------------------------------------------------------
1119     --#      ( ( Latch.IsLocked(Latch.State) and
1120     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1121     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1122     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1123     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1124     --#
1125     --#      Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) and
1126     --#      not Admin.IsDoingOp(TheAdmin) and
1127     --#
1128     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1129     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1130     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1131     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1132     --#
1133     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
1134     --#        ->
1135     --#        ( ( AdminToken.prf_isGood(AdminToken.State) and
1136     --#            AdminToken.prf_authCertValid(AdminToken.State) and
1137     --#            AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )
1138     --#        )
1139     --#      ) and
1140     --#
1141     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1142     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1143     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1144     --#
1145     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1146     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1147     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1148     --#             not Admin.IsDoingOp(TheAdmin) )) and
1149     --#
1150     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
1151     --#        -> ( Admin.IsDoingOp(TheAdmin~) and
1152     --#             Admin.TheCurrentOp(TheAdmin~) = Admin.OverrideLock ) );
1153     is
1154     begin
1155        AuditLog.AddElementToLog
1156          ( ElementID   => AuditTypes.OverrideLock,
1157            Severity    => AuditTypes.Information,
1158            User        => AdminToken.ExtractUser,
1159            Description => AuditTypes.NoDescription
1160            );
1161  
1162        Screen.SetMessage(Msg => Screen.RequestAdminOp);
1163        Display.SetValue(Msg => Display.DoorUnlocked);
1164        Status := EnclaveQuiescent;
1165  
1166        Door.UnlockDoor;
1167        Admin.FinishOp(TheAdmin => TheAdmin);
1168  
1169     end OverrideDoorLockOp;

+++        Flow analysis of subprogram OverrideDoorLockOp 
           performed: no errors found.

1170  
1171  
1172     ------------------------------------------------------------------
1173     -- ShutdownOp
1174     --
1175     -- Description:
1176     --    Performs the shutdown operation
1177     --
1178     -- Implementation Notes:
1179     --    None
1180     --
1181     -- Traceunit : C.Enclave.ShutdownOp
1182     -- Traceto : FD.Enclave.TISShutdownOp
1183     -- Traceto : FD.Enclave.ShutdownOK
1184     -- Traceto : FD.Enclave.ShutdownWaitingDoor
1185     ------------------------------------------------------------------
1186     procedure ShutdownOp(TheAdmin : in out Admin.T)
1187     --# global in     Clock.CurrentTime;
1188     --#        in     ConfigData.State;
1189     --#        in     Clock.Now;
1190     --#        in out AdminToken.State;
1191     --#        in out Status;
1192     --#        in out Screen.State;
1193     --#        in out Display.State;
1194     --#        in out AuditLog.State;
1195     --#        in out AuditLog.FileState;
1196     --#        in out Door.State;
1197     --#        in out Latch.State;
1198     --#        in out UserToken.State;
1199     --# derives AdminToken.State,
1200     --#         Status,
1201     --#         Screen.State,
1202     --#         Display.State,
1203     --#         TheAdmin,
1204     --#         UserToken.State    from *,
1205     --#                                 Door.State &
1206     --#         AuditLog.State,
1207     --#         AuditLog.FileState from AdminToken.State,
1208     --#                                 Clock.CurrentTime,
1209     --#                                 Screen.State,
1210     --#                                 Display.State,
1211     --#                                 AuditLog.State,
1212     --#                                 AuditLog.FileState,
1213     --#                                 ConfigData.State,
1214     --#                                 Clock.Now,
1215     --#                                 Door.State,
1216     --#                                 Latch.State &
1217     --#         Door.State,
1218     --#         Latch.State        from Clock.CurrentTime,
1219     --#                                 Door.State,
1220     --#                                 Latch.State;
1221     --# pre  Status = WaitingStartAdminOp and
1222     --#
1223     --#      Admin.IsPresent(TheAdmin) and
1224     --#      Admin.IsDoingOp(TheAdmin) and
1225     --#      Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp and
1226     --#
1227     --#      --------------------------------------------------------
1228     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1229     --#      --====================================================--
1230     --#      -- Before each call to ShutdownOp, the security       --
1231     --#      -- property holds.                                    --
1232     --#      --------------------------------------------------------
1233     --#      ( ( Latch.IsLocked(Latch.State) and
1234     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1235     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1236     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1237     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1238     --#
1239     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1240     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1241     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1242     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1243     --#
1244     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1245     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1246     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1247     --#             not Admin.IsDoingOp(TheAdmin) ));
1248     --#
1249     --# post ( Status = Shutdown or
1250     --#        Status = WaitingStartAdminOp ) and
1251     --#
1252     --#      ( Status = WaitingStartAdminOp ->
1253     --#        ( Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) and
1254     --#          Admin.IsPresent(TheAdmin) and
1255     --#          Admin.IsDoingOp(TheAdmin) and
1256     --#          Latch.State = Latch.State~ and
1257     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ) and
1258     --#
1259     --#      ( Status = Shutdown ->
1260     --#        ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly and
1261     --#          Latch.IsLocked(Latch.State) and
1262     --#          not Admin.IsDoingOp(TheAdmin) ) ) and
1263     --#
1264     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1265     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
1266     --#                    Status = WaitingStartAdminOp ) and
1267     --#
1268     --#      --------------------------------------------------------
1269     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1270     --#      --====================================================--
1271     --#      -- After each call to ShutdownOp, the security        --
1272     --#      -- property holds.                                    --
1273     --#      --------------------------------------------------------
1274     --#      ( ( Latch.IsLocked(Latch.State) and
1275     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1276     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1277     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1278     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1279     --#
1280     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1281     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1282     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1283     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1284     --#
1285     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
1286     --#        ->
1287     --#        ( ( AdminToken.prf_isGood(AdminToken.State) and
1288     --#            AdminToken.prf_authCertValid(AdminToken.State) and
1289     --#            AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )
1290     --#        )
1291     --#      ) and
1292     --#
1293     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1294     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1295     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1296     --#
1297     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1298     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1299     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1300     --#             not Admin.IsDoingOp(TheAdmin) ));
1301     is
1302     begin
1303        if Door.TheCurrentDoor = Door.Closed then
1304  
1305           -- ShutdownOK actions
1306           Screen.SetMessage(Msg => Screen.Clear);
1307           Display.SetValue(Msg => Display.Blank);
1308           Status := Shutdown;
1309  
1310           Door.LockDoor;
1311           Admin.Logout(TheAdmin => TheAdmin);
1312  
1313           AuditLog.AddElementToLog
1314             ( ElementID   => AuditTypes.Shutdown,
1315               Severity    => AuditTypes.Information,
1316               User        => AdminToken.ExtractUser,
1317               Description => AuditTypes.NoDescription
1318               );
1319  
1320           UserToken.Clear;
1321           AdminToken.Clear;
1322  
1323           --# check Admin.prf_rolePresent (TheAdmin) /= PrivTypes.Guard;
1324  
1325        else
1326           -- ShutdownWaitingDoor actions
1327           Screen.SetMessage(Msg => Screen.CloseDoor);
1328        end if;
1329  
1330     end ShutdownOp;

+++        Flow analysis of subprogram ShutdownOp 
           performed: no errors found.

1331  
1332  
1333     ------------------------------------------------------------------
1334     -- AdminOp
1335     --
1336     -- Description:
1337     --    Performs the admin operation
1338     --
1339     -- Implementation Notes:
1340     --    None
1341     --
1342     -- Traceunit : C.Enclave.AdminOp
1343     -- Traceto: FD.Enclave.TISAdminOpC
1344     ------------------------------------------------------------------
1345     procedure AdminOp(TheAdmin : in out Admin.T)
1346     --# global in     Clock.CurrentTime;
1347     --#        in     Clock.Now;
1348     --#        in     Floppy.Input;
1349     --#        in out AdminToken.State;
1350     --#        in out Status;
1351     --#        in out Screen.State;
1352     --#        in out Display.State;
1353     --#        in out Floppy.State;
1354     --#        in out AuditLog.State;
1355     --#        in out AuditLog.FileState;
1356     --#        in out ConfigData.State;
1357     --#        in out ConfigData.FileState;
1358     --#        in out Door.State;
1359     --#        in out Latch.State;
1360     --#        in out UserToken.State;
1361     --#           out Floppy.Output;
1362     --#        in out Floppy.WrittenState;
1363     --# derives AdminToken.State,
1364     --#         Display.State,
1365     --#         UserToken.State      from *,
1366     --#                                   TheAdmin,
1367     --#                                   Door.State &
1368     --#         Screen.State         from *,
1369     --#                                   Status,
1370     --#                                   Floppy.State,
1371     --#                                   Floppy.WrittenState,
1372     --#                                   Floppy.Input,
1373     --#                                   TheAdmin,
1374     --#                                   Door.State &
1375     --#         Status               from *,
1376     --#                                   Status,
1377     --#                                   Floppy.State,
1378     --#                                   TheAdmin,
1379     --#                                   Door.State &
1380     --#         AuditLog.State,
1381     --#         AuditLog.FileState   from AdminToken.State,
1382     --#                                   Status,
1383     --#                                   Clock.CurrentTime,
1384     --#                                   Screen.State,
1385     --#                                   Display.State,
1386     --#                                   Floppy.State,
1387     --#                                   Floppy.Input,
1388     --#                                   Floppy.WrittenState,
1389     --#                                   AuditLog.State,
1390     --#                                   AuditLog.FileState,
1391     --#                                   ConfigData.State,
1392     --#                                   Clock.Now,
1393     --#                                   TheAdmin,
1394     --#                                   ConfigData.FileState,
1395     --#                                   Door.State,
1396     --#                                   Latch.State &
1397     --#         ConfigData.State,
1398     --#         ConfigData.FileState from *,
1399     --#                                   Status,
1400     --#                                   Floppy.State,
1401     --#                                   TheAdmin &
1402     --#         Door.State,
1403     --#         Latch.State          from Clock.CurrentTime,
1404     --#                                   ConfigData.State,
1405     --#                                   TheAdmin,
1406     --#                                   Door.State,
1407     --#                                   Latch.State &
1408     --#         Floppy.State         from *,
1409     --#                                   Status,
1410     --#                                   Floppy.Input,
1411     --#                                   TheAdmin &
1412     --#         TheAdmin             from *,
1413     --#                                   Status,
1414     --#                                   Door.State &
1415     --#         Floppy.Output from Floppy.State, Status, TheAdmin,
1416     --#                                   AuditLog.State,
1417     --#                                   AuditLog.FileState &
1418     --#         Floppy.WrittenState from *, Floppy.State, Status,
1419     --#                                   AuditLog.State, TheAdmin,
1420     --#                                   AuditLog.FileState;
1421     --# pre  ( Status = WaitingStartAdminOp or
1422     --#        Status = WaitingFinishAdminOp ) and
1423     --#
1424     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1425     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
1426     --#                    Status = WaitingStartAdminOp ) and
1427     --#
1428     --#      Admin.IsPresent(TheAdmin) and
1429     --#      Admin.IsDoingOp(TheAdmin) and
1430     --#
1431     --#      --------------------------------------------------------
1432     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1433     --#      --====================================================--
1434     --#      -- Before each call to AdminOp, the security property --
1435     --#      -- holds.                                             --
1436     --#      --------------------------------------------------------
1437     --#      ( ( Latch.IsLocked(Latch.State) and
1438     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1439     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1440     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1441     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1442     --#
1443     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1444     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1445     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1446     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1447     --#
1448     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1449     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1450     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1451     --#
1452     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1453     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1454     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1455     --#             not Admin.IsDoingOp(TheAdmin) ));
1456     --#
1457     --#
1458     --# post ( Status = WaitingStartAdminOp or
1459     --#        Status = WaitingFinishAdminOp or
1460     --#        Status = EnclaveQuiescent or
1461     --#        Status = Shutdown ) and
1462     --#
1463     --#      ( ( Status = WaitingStartAdminOp or
1464     --#          Status = WaitingFinishAdminOp ) ->
1465     --#        ( Admin.IsDoingOp(TheAdmin) and
1466     --#          Admin.IsPresent(TheAdmin) and
1467     --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
1468     --#
1469     --#      ( Status = EnclaveQuiescent ->
1470     --#        ( not Admin.IsDoingOp(TheAdmin) and
1471     --#          Admin.IsPresent(TheAdmin) and
1472     --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
1473     --#
1474     --#      ( Status = Shutdown ->
1475     --#        ( not Admin.IsDoingOp(TheAdmin) and
1476     --#          Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly ) ) and
1477     --#
1478     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1479     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
1480     --#                    Status = WaitingStartAdminOp ) and
1481     --#
1482     --#      --------------------------------------------------------
1483     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1484     --#      --====================================================--
1485     --#      -- After each call to AdminOp, the security property  --
1486     --#      -- holds.                                             --
1487     --#      --------------------------------------------------------
1488     --#      ( ( Latch.IsLocked(Latch.State) and
1489     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1490     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1491     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1492     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1493     --#
1494     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1495     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1496     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1497     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1498     --#
1499     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
1500     --#        ->
1501     --#        ( ( AdminToken.prf_isGood(AdminToken.State) and
1502     --#            AdminToken.prf_authCertValid(AdminToken.State) and
1503     --#            AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )
1504     --#        )
1505     --#      ) and
1506     --#
1507     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1508     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1509     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1510     --#
1511     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1512     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1513     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1514     --#             not Admin.IsDoingOp(TheAdmin) )) and
1515     --#
1516     --# --     ( Latch.IsLocked(Latch.State) <->
1517     --# --       Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1518     --# --                                Latch.prf_LatchTimeout(Latch.State)) ) and
1519     --#
1520     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
1521     --#        -> ( Admin.IsDoingOp(TheAdmin~) and
1522     --#             Admin.TheCurrentOp(TheAdmin~) = Admin.OverrideLock ) );
1523     is
1524     begin
1525        case Admin.TheCurrentOp(TheAdmin) is
1526           when Admin.ArchiveLog =>
1527              ArchiveLogOp(TheAdmin => TheAdmin);
1528  
1529           when Admin.UpdateConfigData =>
1530              UpdateConfigDataOp(TheAdmin => TheAdmin);
1531  
1532           when Admin.OverrideLock =>
1533              OverrideDoorLockOp(TheAdmin => TheAdmin);
1534  
1535           when Admin.ShutdownOp =>
1536              ShutdownOp(TheAdmin => TheAdmin);
1537        end case;
1538     end AdminOp;

+++        Flow analysis of subprogram AdminOp performed: 
           no errors found.

1539  
1540  
1541     ------------------------------------------------------------------
1542     -- Exported subprocedures
1543     --
1544     ------------------------------------------------------------------
1545     ------------------------------------------------------------------
1546     -- EnrolmentIsInProgress
1547     --
1548     -- Implementation Notes:
1549     --    None.
1550     ------------------------------------------------------------------
1551     function EnrolmentIsInProgress return Boolean
1552     --# global Status;
1553     is
1554     begin
1555        return Status in EnrolmentStates;
1556     end EnrolmentIsInProgress;

+++        Flow analysis of subprogram 
           EnrolmentIsInProgress performed: no errors found.

1557  
1558  
1559     ------------------------------------------------------------------
1560     -- Init
1561     --
1562     -- Implementation Notes:
1563     --    None.
1564     ------------------------------------------------------------------
1565     procedure Init
1566     --# global in     KeyStore.State;
1567     --#           out Status;
1568     --# derives Status from KeyStore.State;
1569     --# post ( KeyStore.PrivateKeyPresent(KeyStore.State) <->
1570     --#           not EnrolmentIsInProgress(Status) ) and
1571     --#      ( EnrolmentIsInProgress(Status) or
1572     --#        Status = EnclaveQuiescent );
1573     is
1574     begin
1575        if KeyStore.PrivateKeyPresent then
1576           Status := EnclaveQuiescent;
1577        else
1578           Status := NotEnrolled;
1579        end if;
1580     end Init;

+++        Flow analysis of subprogram Init performed: no 
           errors found.

1581  
1582  
1583     ------------------------------------------------------------------
1584     -- AdminMustLogout
1585     --
1586     -- Implementation Notes:
1587     --    None.
1588     ------------------------------------------------------------------
1589     function AdminMustLogout (TheAdmin : Admin.T) return Boolean
1590     --# global AdminToken.State,
1591     --#        Status,
1592     --#        Clock.CurrentTime;
1593     is
1594     begin
1595  
1596        return PresentAdminHasDeparted( TheAdmin => TheAdmin) or
1597               AdminTokenHasExpired( TheAdmin => TheAdmin);
1598  
1599     end AdminMustLogout;

+++        Flow analysis of subprogram AdminMustLogout 
           performed: no errors found.

1600  
1601     ------------------------------------------------------------------
1602     -- CurrentAdminActivityPossible
1603     --
1604     -- Implementation Notes:
1605     --    None.
1606     ------------------------------------------------------------------
1607     function CurrentAdminActivityPossible return Boolean
1608     --# global AdminToken.State,
1609     --#        Status;
1610     --# return R => (R -> Status in NonQuiescentStates);
1611     is
1612  
1613        ------------------------------------------------------------------
1614        -- AdminActivityInProgress
1615        --
1616        -- Description:
1617        --    Returns True exactly when the current status represents
1618        --    present activity in the enclave.
1619        --
1620        -- Implementation Notes:
1621        --    None.
1622        ------------------------------------------------------------------
1623        function AdminActivityInProgress return Boolean
1624          --# global Status;
1625        is
1626        begin
1627           return Status in ActiveEnclaveStates ;
1628        end AdminActivityInProgress;

+++        Flow analysis of subprogram 
           AdminActivityInProgress performed: no errors found.

1629  
1630  
1631     ------------------------------------------------------------------
1632     -- begin CurrentAdminActivityPossible
1633     ------------------------------------------------------------------
1634     begin
1635        return AdminHasDeparted or AdminActivityInProgress;
1636  
1637     end CurrentAdminActivityPossible;

+++        Flow analysis of subprogram 
           CurrentAdminActivityPossible performed: no errors found.

1638  
1639     ------------------------------------------------------------------
1640     -- HasShutdown
1641     --
1642     -- Description:
1643     --    Returns true if and only if the system is in a shutdown state.
1644     --
1645     -- traceunit : C.Enclave.HasShutdown
1646     -- traceto :
1647     ------------------------------------------------------------------
1648     function HasShutdown return Boolean
1649     --# global Status;
1650     is
1651     begin
1652        return Status = Shutdown;
1653     end HasShutdown;

+++        Flow analysis of subprogram HasShutdown 
           performed: no errors found.

1654  
1655     ------------------------------------------------------------------
1656     -- EnrolOp
1657     --
1658     -- Implementation Notes:
1659     --    None.
1660     ------------------------------------------------------------------
1661     procedure EnrolOp
1662     --# global in     ConfigData.State;
1663     --#        in     Clock.Now;
1664     --#        in     Floppy.Input;
1665     --#        in out Status;
1666     --#        in out Screen.State;
1667     --#        in out Display.State;
1668     --#        in out Floppy.State;
1669     --#        in out AuditLog.State;
1670     --#        in out AuditLog.FileState;
1671     --#        in out KeyStore.Store;
1672     --#        in out KeyStore.State;
1673     --# derives Status,
1674     --#         Screen.State,
1675     --#         Display.State,
1676     --#         KeyStore.Store,
1677     --#         KeyStore.State     from *,
1678     --#                                 Status,
1679     --#                                 Floppy.State,
1680     --#                                 KeyStore.Store &
1681     --#         AuditLog.State,
1682     --#         AuditLog.FileState from Status,
1683     --#                                 Screen.State,
1684     --#                                 Display.State,
1685     --#                                 Floppy.State,
1686     --#                                 AuditLog.State,
1687     --#                                 AuditLog.FileState,
1688     --#                                 ConfigData.State,
1689     --#                                 Clock.Now,
1690     --#                                 KeyStore.Store &
1691     --#         Floppy.State       from *,
1692     --#                                 Status,
1693     --#                                 Floppy.Input;
1694     --# pre EnrolmentIsInProgress(Status) and
1695     --#     not KeyStore.PrivateKeyPresent(KeyStore.State);
1696     --# post ( KeyStore.PrivateKeyPresent(KeyStore.State) <->
1697     --#           not EnrolmentIsInProgress(Status) ) and
1698     --#      ( EnrolmentIsInProgress(Status) or
1699     --#        Status = EnclaveQuiescent );
1700     is
1701        LocalStatus : EnrolmentStates;
1702     begin
1703        LocalStatus := EnrolmentStates'(Status);
1704  
1705        case LocalStatus is
1706           when NotEnrolled =>
1707              ReadEnrolmentData;
1708  
1709           when WaitingEnrol =>
1710              ValidateEnrolmentData;
1711  
1712           when WaitingEndEnrol =>
1713              CompleteFailedEnrolment;
1714  
1715        end case;
1716  
1717        --# check EnrolmentIsInProgress(Status) <-> Status in EnrolmentStates;
1718  
1719     end EnrolOp;

+++        Flow analysis of subprogram EnrolOp performed: 
           no errors found.

1720  
1721     ------------------------------------------------------------------
1722     -- AdminLogout
1723     --
1724     -- Implementation Notes:
1725     --    Setting of screen message is postponed to the
1726     --    TIS program since we cannot determine whether the
1727     --    user entry is in progress from here.
1728     ------------------------------------------------------------------
1729     procedure AdminLogout (TheAdmin : in out Admin.T)
1730     --# global in     ConfigData.State;
1731     --#        in     Clock.Now;
1732     --#        in out AdminToken.State;
1733     --#        in out Status;
1734     --#        in out AuditLog.State;
1735     --#        in out AuditLog.FileState;
1736     --# derives AdminToken.State,
1737     --#         Status             from *,
1738     --#                                 AdminToken.State,
1739     --#                                 Status,
1740     --#                                 TheAdmin &
1741     --#         AuditLog.State,
1742     --#         AuditLog.FileState from AdminToken.State,
1743     --#                                 Status,
1744     --#                                 AuditLog.State,
1745     --#                                 AuditLog.FileState,
1746     --#                                 ConfigData.State,
1747     --#                                 Clock.Now,
1748     --#                                 TheAdmin &
1749     --#         TheAdmin           from ;
1750     --# pre not EnrolmentIsInProgress(Status) and
1751     --#      ( ( Status = WaitingStartAdminOp or
1752     --#          Status = WaitingFinishAdminOp ) ->
1753     --#        ( Admin.IsDoingOp(TheAdmin) and
1754     --#          Admin.IsPresent(TheAdmin) ) );
1755     --# post not EnrolmentIsInProgress(Status) and
1756     --#      Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly and
1757     --#      not Admin.IsDoingOp(TheAdmin) and
1758     --#      ( Status = EnclaveQuiescent or
1759     --#        Status = WaitingRemoveAdminTokenFail or
1760     --#        Status = Status~ ) and
1761     --#      not ( Status = WaitingStartAdminOp or
1762     --#            Status = WaitingFinishAdminOp );
1763     is
1764     begin
1765        if PresentAdminHasDeparted(TheAdmin) then
1766           if Status = EnclaveQuiescent then
1767  
1768              -- TokenRemovedAdminLogoutC actions
1769              AuditLog.AddElementToLog
1770                ( ElementID   => AuditTypes.AdminTokenRemoved,
1771                  Severity    => AuditTypes.Information,
1772                  User        => AdminToken.ExtractUser,
1773                  Description => AuditTypes.NoDescription
1774                  );
1775  
1776              AdminTokenTear;
1777  
1778           elsif Status = WaitingStartAdminOp or
1779                  Status = WaitingFinishAdminOp then
1780  
1781              -- BadAdminLogoutC
1782              BadAdminTokenTear;
1783  
1784           end if;
1785        else -- AdminTokenHasExpired
1786  
1787           -- AdminTokenTimeoutC actions
1788           AuditLog.AddElementToLog
1789             ( ElementID   => AuditTypes.AdminTokenExpired,
1790               Severity    => AuditTypes.Warning,
1791               User        => AdminToken.ExtractUser,
1792               Description => AuditTypes.NoDescription
1793               );
1794  
1795           Status := WaitingRemoveAdminTokenFail;
1796  
1797        end if;
1798  
1799        Admin.Logout(TheAdmin => TheAdmin);
1800  
1801     end AdminLogout;

+++        Flow analysis of subprogram AdminLogout 
           performed: no errors found.

1802  
1803     ------------------------------------------------------------------
1804     -- ProgressAdminActivity
1805     --
1806     -- Implementation Notes:
1807     --    None
1808     ------------------------------------------------------------------
1809     procedure ProgressAdminActivity (TheAdmin : in out Admin.T)
1810     --# global in     Clock.CurrentTime;
1811     --#        in     Clock.Now;
1812     --#        in     Floppy.Input;
1813     --#        in     KeyStore.Store;
1814     --#        in     KeyStore.State;
1815     --#        in     AdminToken.Input;
1816     --#        in out AdminToken.State;
1817     --#        in out Status;
1818     --#        in out Screen.State;
1819     --#        in out Display.State;
1820     --#        in out Floppy.State;
1821     --#        in out AuditLog.State;
1822     --#        in out AuditLog.FileState;
1823     --#        in out ConfigData.State;
1824     --#        in out AdminToken.Status;
1825     --#        in out ConfigData.FileState;
1826     --#        in out Door.State;
1827     --#        in out Latch.State;
1828     --#        in out UserToken.State;
1829     --#           out Floppy.Output;
1830     --#        in out Floppy.WrittenState;
1831     --# derives AdminToken.State,
1832     --#         TheAdmin             from AdminToken.State,
1833     --#                                   Status,
1834     --#                                   Clock.CurrentTime,
1835     --#                                   KeyStore.Store,
1836     --#                                   KeyStore.State,
1837     --#                                   TheAdmin,
1838     --#                                   AdminToken.Status,
1839     --#                                   AdminToken.Input,
1840     --#                                   Door.State &
1841     --#         Screen.State         from *,
1842     --#                                   AdminToken.State,
1843     --#                                   Status,
1844     --#                                   Clock.CurrentTime,
1845     --#                                   Floppy.State,
1846     --#                                   Floppy.WrittenState,
1847     --#                                   Floppy.Input,
1848     --#                                   KeyStore.Store,
1849     --#                                   KeyStore.State,
1850     --#                                   TheAdmin,
1851     --#                                   AdminToken.Status,
1852     --#                                   AdminToken.Input,
1853     --#                                   Door.State &
1854     --#         Status               from *,
1855     --#                                   AdminToken.State,
1856     --#                                   Status,
1857     --#                                   Clock.CurrentTime,
1858     --#                                   Floppy.State,
1859     --#                                   KeyStore.Store,
1860     --#                                   KeyStore.State,
1861     --#                                   TheAdmin,
1862     --#                                   AdminToken.Status,
1863     --#                                   AdminToken.Input,
1864     --#                                   Door.State &
1865     --#         Display.State,
1866     --#         UserToken.State      from *,
1867     --#                                   Status,
1868     --#                                   TheAdmin,
1869     --#                                   Door.State &
1870     --#         AuditLog.State,
1871     --#         AuditLog.FileState   from AdminToken.State,
1872     --#                                   Status,
1873     --#                                   Clock.CurrentTime,
1874     --#                                   Screen.State,
1875     --#                                   Display.State,
1876     --#                                   Floppy.State,
1877     --#                                   AuditLog.State,
1878     --#                                   Floppy.Input,
1879     --#                                   Floppy.WrittenState,
1880     --#                                   AuditLog.FileState,
1881     --#                                   ConfigData.State,
1882     --#                                   Clock.Now,
1883     --#                                   KeyStore.Store,
1884     --#                                   KeyStore.State,
1885     --#                                   TheAdmin,
1886     --#                                   AdminToken.Status,
1887     --#                                   AdminToken.Input,
1888     --#                                   ConfigData.FileState,
1889     --#                                   Door.State,
1890     --#                                   Latch.State &
1891     --#         ConfigData.State,
1892     --#         ConfigData.FileState from *,
1893     --#                                   Status,
1894     --#                                   Floppy.State,
1895     --#                                   TheAdmin &
1896     --#         Door.State,
1897     --#         Latch.State          from Status,
1898     --#                                   Clock.CurrentTime,
1899     --#                                   ConfigData.State,
1900     --#                                   TheAdmin,
1901     --#                                   Door.State,
1902     --#                                   Latch.State &
1903     --#         Floppy.State         from *,
1904     --#                                   Status,
1905     --#                                   Floppy.Input,
1906     --#                                   TheAdmin &
1907     --#         AdminToken.Status    from *,
1908     --#                                   AdminToken.State,
1909     --#                                   Status &
1910     --#         Floppy.Output from Floppy.State, Status, TheAdmin,
1911     --#                                   AuditLog.State,
1912     --#                                   AuditLog.FileState &
1913     --#         Floppy.WrittenState from *, Floppy.State, Status,
1914     --#                                   AuditLog.State, TheAdmin,
1915     --#                                   AuditLog.FileState;
1916     --#
1917     --# pre not EnrolmentIsInProgress(Status) and
1918     --#     CurrentAdminActivityPossible(AdminToken.State, Status) and
1919     --#      --------------------------------------------------------
1920     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1921     --#      --====================================================--
1922     --#      -- Before each call to ProgressAdminActivity, the     --
1923     --#      -- security property holds.                           --
1924     --#      --------------------------------------------------------
1925     --#      ( ( Latch.IsLocked(Latch.State) and
1926     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1927     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1928     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1929     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1930     --#
1931     --#      ( ( Status = GotAdminToken or
1932     --#          Status = WaitingRemoveAdminTokenFail ) -> not Admin.IsPresent(TheAdmin) ) and
1933     --#
1934     --#      ( not Admin.IsPresent(TheAdmin) -> not Admin.IsDoingOp(TheAdmin) ) and
1935     --#
1936     --#      ( ( Status = WaitingStartAdminOp or
1937     --#          Status = WaitingFinishAdminOp ) ->
1938     --#        ( Admin.IsPresent(TheAdmin) and
1939     --#          Admin.IsDoingOp(TheAdmin) ) ) and
1940     --#
1941     --#      ( Status = EnclaveQuiescent ->
1942     --#        not Admin.IsDoingOp(TheAdmin) ) and
1943     --#
1944     --#      ( Status = Shutdown ->
1945     --#        ( not Admin.IsDoingOp(TheAdmin) and
1946     --#          Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly ) ) and
1947     --#
1948     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1949     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
1950     --#                    Status = WaitingStartAdminOp ) and
1951     --#
1952     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1953     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1954     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1955     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1956     --#
1957     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1958     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1959     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1960     --#
1961     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1962     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1963     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
1964     --#             not Admin.IsDoingOp(TheAdmin) ));
1965     --#
1966     --#
1967     --# post not EnrolmentIsInProgress(Status) and
1968     --#      --------------------------------------------------------
1969     --#      -- PROOF ANNOTATIONS FOR SECURITY PROPERTY 3          --
1970     --#      --====================================================--
1971     --#      -- After each call to ProgressAdminActivity, the      --
1972     --#      -- security property holds.                           --
1973     --#      --------------------------------------------------------
1974     --#      ( ( Latch.IsLocked(Latch.State) and
1975     --#          Door.TheCurrentDoor(Door.State) = Door.Open and
1976     --#          Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
1977     --#                                   Door.prf_alarmTimeout(Door.State)) ) <->
1978     --#        Door.TheDoorAlarm(Door.State) = AlarmTypes.Alarming ) and
1979     --#
1980     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1981     --#           ( AdminToken.prf_isGood(AdminToken.State) and
1982     --#             AdminToken.prf_authCertValid(AdminToken.State) and
1983     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
1984     --#
1985     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
1986     --#        ->
1987     --#        ( ( AdminToken.prf_isGood(AdminToken.State) and
1988     --#            AdminToken.prf_authCertValid(AdminToken.State) and
1989     --#            AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )
1990     --#        )
1991     --#      ) and
1992     --#
1993     --#      ( ( Admin.IsDoingOp(TheAdmin) and
1994     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
1995     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
1996     --#
1997     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
1998     --#           ( ( Admin.IsDoingOp(TheAdmin) and
1999     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
2000     --#             not Admin.IsDoingOp(TheAdmin) )) and
2001     --#
2002     --#      ( not Admin.IsPresent(TheAdmin) -> not Admin.IsDoingOp(TheAdmin) ) and
2003     --#
2004     --#      ( ( Status = GotAdminToken or
2005     --#          Status = WaitingRemoveAdminTokenFail ) -> not Admin.IsPresent(TheAdmin) ) and
2006     --#
2007     --#      ( ( Status = WaitingStartAdminOp or
2008     --#          Status = WaitingFinishAdminOp ) ->
2009     --#        ( Admin.IsDoingOp(TheAdmin) and
2010     --#          Admin.IsPresent(TheAdmin) and
2011     --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
2012     --#
2013     --#      ( Status = EnclaveQuiescent ->
2014     --#        ( not Admin.IsDoingOp(TheAdmin) ) ) and
2015     --#
2016     --#      ( Status = Shutdown ->
2017     --#        ( not Admin.IsDoingOp(TheAdmin) and
2018     --#          Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly ) ) and
2019     --#
2020     --#      ( ( Admin.IsDoingOp(TheAdmin) and
2021     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
2022     --#                    Status = WaitingStartAdminOp ) and
2023     --#
2024     --# --     ( Latch.IsLocked(Latch.State) <->
2025     --# --       Clock.GreaterThanOrEqual(Clock.TheCurrentTime(Clock.CurrentTime),
2026     --# --                                Latch.prf_LatchTimeout(Latch.State)) ) and
2027     --#
2028     --#      ( ( not Latch.IsLocked(Latch.State) and Latch.IsLocked(Latch.State~) )
2029     --#        -> ( Admin.IsDoingOp(TheAdmin~) and
2030     --#             Admin.TheCurrentOp(TheAdmin~) = Admin.OverrideLock ) );
2031     is
2032        LocalStatus : NonQuiescentStates;
2033     begin
2034        LocalStatus := NonQuiescentStates'(Status);
2035  
2036        case LocalStatus is
2037           -- TISProgressAdminLogon
2038           when GotAdminToken =>
2039              ValidateAdminToken (TheAdmin => TheAdmin);
2040              --# check Status > WaitingEndEnrol;
2041           when WaitingRemoveAdminTokenFail =>
2042              CompleteFailedAdminLogon;
2043              --# check Admin.prf_rolePresent(TheAdmin) /= PrivTypes.Guard;
2044           -- TISAdminOp
2045           when WaitingStartAdminOp | WaitingFinishAdminOp =>
2046              AdminOp(TheAdmin => TheAdmin);
2047              --# check Status > WaitingEndEnrol;
2048           when Shutdown =>
2049              null;
2050        end case;
2051  
2052     end ProgressAdminActivity;

+++        Flow analysis of subprogram 
           ProgressAdminActivity performed: no errors found.

2053  
2054     ------------------------------------------------------------------
2055     -- StartAdminActivity
2056     --
2057     -- Implementation Notes:
2058     --    When attempting to logon an administrator, the physical reading
2059     --    of the certificates from the token is postponed until validation
2060     --    since only as many certificates as are required to do this
2061     --    validation are read from the token.
2062     --
2063     ------------------------------------------------------------------
2064     procedure StartAdminActivity (TheAdmin : in out Admin.T)
2065     --# global in     AdminToken.State;
2066     --#        in     ConfigData.State;
2067     --#        in     Clock.Now;
2068     --#        in     Keyboard.Input;
2069     --#        in out Status;
2070     --#        in out Screen.State;
2071     --#        in out AuditLog.State;
2072     --#        in out AuditLog.FileState;
2073     --# derives Status,
2074     --#         Screen.State,
2075     --#         TheAdmin           from *,
2076     --#                                 AdminToken.State,
2077     --#                                 Status,
2078     --#                                 TheAdmin,
2079     --#                                 Keyboard.Input &
2080     --#         AuditLog.State,
2081     --#         AuditLog.FileState from AdminToken.State,
2082     --#                                 Status,
2083     --#                                 Screen.State,
2084     --#                                 AuditLog.State,
2085     --#                                 AuditLog.FileState,
2086     --#                                 ConfigData.State,
2087     --#                                 Clock.Now,
2088     --#                                 TheAdmin,
2089     --#                                 Keyboard.Input;
2090     --#
2091     --# pre not EnrolmentIsInProgress(Status) and
2092     --#
2093     --# --     ( prf_StatusIsGotAdminToken(State) -> not Admin.IsPresent(TheAdmin) ) and
2094     --#
2095     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2096     --#           ( AdminToken.prf_isGood(AdminToken.State) and
2097     --#             AdminToken.prf_authCertValid(AdminToken.State) and
2098     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
2099     --#
2100     --#      ( not Admin.IsPresent(TheAdmin) -> not Admin.IsDoingOp(TheAdmin) ) and
2101     --#
2102     --#      ( ( Status = GotAdminToken or
2103     --#          Status = WaitingRemoveAdminTokenFail ) -> not Admin.IsPresent(TheAdmin) ) and
2104     --#
2105     --#      ( ( Status = WaitingStartAdminOp or
2106     --#          Status = WaitingFinishAdminOp ) ->
2107     --#        ( Admin.IsPresent(TheAdmin) and
2108     --#          Admin.IsDoingOp(TheAdmin) ) ) and
2109     --#
2110     --#      ( Status = EnclaveQuiescent ->
2111     --#        not Admin.IsDoingOp(TheAdmin) ) and
2112     --#
2113     --#      ( Status = Shutdown ->
2114     --#        ( not Admin.IsDoingOp(TheAdmin) and
2115     --#          Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly ) ) and
2116     --#
2117     --#      ( ( Admin.IsDoingOp(TheAdmin) and
2118     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
2119     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
2120     --#
2121     --#      ( ( Admin.IsDoingOp(TheAdmin) and
2122     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
2123     --#                    Status = WaitingStartAdminOp ) and
2124     --#
2125     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2126     --#           ( ( Admin.IsDoingOp(TheAdmin) and
2127     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
2128     --#             not Admin.IsDoingOp(TheAdmin) ));
2129     --#
2130     --#
2131     --# post not EnrolmentIsInProgress(Status) and
2132     --#
2133     --#      ( not Admin.IsPresent(TheAdmin) -> not Admin.IsDoingOp(TheAdmin) ) and
2134     --#
2135     --#      ( ( Status = GotAdminToken or
2136     --#          Status = WaitingRemoveAdminTokenFail ) -> not Admin.IsPresent(TheAdmin) ) and
2137     --#
2138     --#      ( ( Status = WaitingStartAdminOp or
2139     --#          Status = WaitingFinishAdminOp ) ->
2140     --#        ( Admin.IsDoingOp(TheAdmin) and
2141     --#          Admin.IsPresent(TheAdmin) and
2142     --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
2143     --#
2144     --#      ( Status = EnclaveQuiescent ->
2145     --#        ( not Admin.IsDoingOp(TheAdmin) and
2146     --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
2147     --#
2148     --#      ( Status = Shutdown ->
2149     --#        ( not Admin.IsDoingOp(TheAdmin) and
2150     --#          Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly ) ) and
2151     --#
2152     --#      ( ( Admin.IsDoingOp(TheAdmin) and
2153     --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
2154     --#                    Status = WaitingStartAdminOp ) and
2155     --#
2156     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2157     --#           ( AdminToken.prf_isGood(AdminToken.State) and
2158     --#             AdminToken.prf_authCertValid(AdminToken.State) and
2159     --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
2160     --#
2161     --#      ( ( Admin.IsDoingOp(TheAdmin) and
2162     --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
2163     --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
2164     --#
2165     --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2166     --#           ( ( Admin.IsDoingOp(TheAdmin) and
2167     --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
2168     --#             not Admin.IsDoingOp(TheAdmin) ));
2169     --#
2170     is
2171  
2172        ------------------------------------------------------------------
2173        -- AdminLogonCanStart
2174        --
2175        -- Description:
2176        --    Returns True exactly when there is no administrator
2177        --    logged on and the enclave is quiescent, but an administrator
2178        --    token is present.
2179        --
2180        -- Implementation Notes:
2181        --    None.
2182        --
2183        -- Traceunit : C.Enclave.AdminLogonCanStart
2184        -- Traceto   : FD.Enclave.AdminLogonCanStart
2185        ------------------------------------------------------------------
2186        function AdminLogonCanStart return Boolean
2187        --# global AdminToken.State,
2188        --#        Status,
2189        --#        TheAdmin;
2190        --# return R => (R -> not Admin.IsPresent(TheAdmin));
2191        is
2192        begin
2193           return ( not Admin.IsPresent(TheAdmin)
2194                    and Status = EnclaveQuiescent
2195                    and AdminToken.IsPresent );
2196        end AdminLogonCanStart;

+++        Flow analysis of subprogram AdminLogonCanStart 
           performed: no errors found.

2197  
2198  
2199        ------------------------------------------------------------------
2200        -- AdminOpCanStart
2201        --
2202        -- Description:
2203        --    Returns True exactly when a logged on administrator's
2204        --    token is present and the enclave is quiescent.
2205        --
2206        -- Implementation Notes:
2207        --    None.
2208        --
2209        -- Traceunit : C.Enclave.AdminOpCanStart
2210        -- Traceto   : FD.Enclave.AdminOpCanStart
2211        ------------------------------------------------------------------
2212        function AdminOpCanStart return Boolean
2213        --# global AdminToken.State,
2214        --#        Status,
2215        --#        TheAdmin;
2216        --# return R => ((R -> Status = EnclaveQuiescent) and
2217        --#              (R -> Admin.IsPresent(TheAdmin)));
2218        is
2219        begin
2220           return ( Admin.IsPresent(TheAdmin)
2221                    and Status = EnclaveQuiescent
2222                    and AdminToken.IsPresent );
2223        end AdminOpCanStart;

+++        Flow analysis of subprogram AdminOpCanStart 
           performed: no errors found.

2224  
2225  
2226        ------------------------------------------------------------------
2227        -- StartAdminOp
2228        --
2229        -- Description:
2230        --    Checks whether the administrator has requested a (valid)
2231        --    operation via the keyboard.
2232        --
2233        -- Implementation Notes:
2234        --    None
2235        --
2236        -- Traceunit : C.Enclave.StartAdminOp
2237        -- Traceto   : FD.Enclave.TISStartAdminOpC
2238        ------------------------------------------------------------------
2239        procedure StartAdminOp
2240        --# global in     AdminToken.State;
2241        --#        in     ConfigData.State;
2242        --#        in     Clock.Now;
2243        --#        in     Keyboard.Input;
2244        --#        in out Status;
2245        --#        in out Screen.State;
2246        --#        in out AuditLog.State;
2247        --#        in out AuditLog.FileState;
2248        --#        in out TheAdmin;
2249        --# derives Status,
2250        --#         Screen.State,
2251        --#         TheAdmin           from *,
2252        --#                                 TheAdmin,
2253        --#                                 Keyboard.Input &
2254        --#         AuditLog.State,
2255        --#         AuditLog.FileState from AdminToken.State,
2256        --#                                 Screen.State,
2257        --#                                 AuditLog.State,
2258        --#                                 AuditLog.FileState,
2259        --#                                 ConfigData.State,
2260        --#                                 Clock.Now,
2261        --#                                 TheAdmin,
2262        --#                                 Keyboard.Input;
2263        --# pre AdminOpCanStart(AdminToken.State, Status, TheAdmin) and
2264        --#     Status = EnclaveQuiescent and
2265        --#
2266        --#     Admin.IsPresent(TheAdmin) and
2267        --#     not Admin.IsDoingOp(TheAdmin) and
2268        --#
2269        --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2270        --#           ( AdminToken.prf_isGood(AdminToken.State) and
2271        --#             AdminToken.prf_authCertValid(AdminToken.State) and
2272        --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
2273        --#
2274        --#      ( ( Admin.IsDoingOp(TheAdmin) and
2275        --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
2276        --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
2277        --#
2278        --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2279        --#           ( ( Admin.IsDoingOp(TheAdmin) and
2280        --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
2281        --#             not Admin.IsDoingOp(TheAdmin) ));
2282        --#
2283        --#
2284        --# post ( Status = EnclaveQuiescent or
2285        --#        Status = WaitingStartAdminOp ) and
2286        --#
2287        --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2288        --#           ( AdminToken.prf_isGood(AdminToken.State) and
2289        --#             AdminToken.prf_authCertValid(AdminToken.State) and
2290        --#             AdminToken.TheAuthCertRole(AdminToken.State) = PrivTypes.Guard )) and
2291        --#
2292        --#      ( ( Admin.IsDoingOp(TheAdmin) and
2293        --#          Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) ->
2294        --#           Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ) and
2295        --#
2296        --#      ( Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard ->
2297        --#           ( ( Admin.IsDoingOp(TheAdmin) and
2298        --#               Admin.TheCurrentOp(TheAdmin) = Admin.OverrideLock ) or
2299        --#             not Admin.IsDoingOp(TheAdmin) )) and
2300        --#
2301        --#      ( ( Admin.IsDoingOp(TheAdmin) and
2302        --#          Admin.TheCurrentOp(TheAdmin) = Admin.ShutdownOp ) ->
2303        --#                    Status = WaitingStartAdminOp ) and
2304        --#
2305        --#      ( ( Status = WaitingStartAdminOp or
2306        --#          Status = WaitingFinishAdminOp ) ->
2307        --#        ( Admin.IsDoingOp(TheAdmin) and
2308        --#          Admin.IsPresent(TheAdmin) and
2309        --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
2310        --#
2311        --#      ( Status = EnclaveQuiescent ->
2312        --#        ( not Admin.IsDoingOp(TheAdmin) and
2313        --#          Admin.prf_rolePresent(TheAdmin) = Admin.prf_rolePresent(TheAdmin~) ) ) and
2314        --#
2315        --#      ( Status = Shutdown ->
2316        --#        ( not Admin.IsDoingOp(TheAdmin) and
2317        --#          Admin.prf_rolePresent(TheAdmin) = PrivTypes.UserOnly ) );
2318        is
2319           KeyedDataPresence : BasicTypes.PresenceT;
2320           KeyedData         : Keyboard.DataT;
2321           TheOp             : Admin.OpAndNullT;
2322        begin
2323           Keyboard.Read(DataPresence => KeyedDataPresence,
2324                         Data         => KeyedData);
2325  
2326           if KeyedDataPresence = BasicTypes.Present then
2327              TheOp := Admin.OpIsAvailable(TheAdmin => TheAdmin,
2328                                           KeyedOp  => KeyedData);
2329              --# check TheOp /= Admin.NullOp ->
2330              --#         (TheOp = Admin.OverrideLock <->
2331              --#            Admin.prf_rolePresent(TheAdmin) = PrivTypes.Guard);
2332  
2333              if TheOp /= Admin.NullOp then
2334  
2335                 -- ValidateOpRequestOK actions
2336                 Status := WaitingStartAdminOp;
2337  
2338                 Screen.SetMessage(Msg => Screen.DoingOp);
2339                 Admin.StartOp(TheAdmin => TheAdmin,
2340                               Op       => TheOp);
2341  
2342                 AuditLog.AddElementToLog
2343                   ( ElementID   => AuditTypes.OperationStart,
2344                     Severity    => AuditTypes.Information,
2345                     User        => AdminToken.ExtractUser,
2346                     Description => KeyedData.Text
2347                     );
2348              else
2349  
2350                 -- ValidateOpRequestFail actions
2351                 Screen.SetMessage(Msg => Screen.InvalidRequest);
2352  
2353                 AuditLog.AddElementToLog
2354                   ( ElementID   => AuditTypes.InvalidOpRequest,
2355                     Severity    => AuditTypes.Warning,
2356                     User        => AdminToken.ExtractUser,
2357                     Description => KeyedData.Text
2358                     );
2359              end if;
2360           end if; -- NoOpRequest
2361  
2362        end StartAdminOp;

+++        Flow analysis of subprogram StartAdminOp 
           performed: no errors found.

2363  
2364     ------------------------------------------------------------------
2365     -- begin StartAdminActivity
2366     ------------------------------------------------------------------
2367     begin
2368        if AdminLogonCanStart then
2369           Status := GotAdminToken;
2370           --# check not Admin.IsPresent(TheAdmin);
2371        elsif AdminOpCanStart then
2372           --# check Status = EnclaveQuiescent;
2373           StartAdminOp;
2374           --# check Status > WaitingEndEnrol ;
2375        end if;
2376     end StartAdminActivity;

+++        Flow analysis of subprogram StartAdminActivity 
           performed: no errors found.

2377  
2378     ------------------------------------------------------------------
2379     -- ResetScreenMessage
2380     --
2381     -- Implementation Notes:
2382     --    None.
2383     --
2384     ------------------------------------------------------------------
2385     procedure ResetScreenMessage
2386       (TheAdmin : in Admin.T)
2387     --# global in     Status;
2388     --#        in     ConfigData.State;
2389     --#        in     Clock.Now;
2390     --#        in out AuditLog.State;
2391     --#        in out AuditLog.FileState;
2392     --#        in out Screen.State;
2393     --# derives Screen.State       from *,
2394     --#                                 Status,
2395     --#                                 TheAdmin &
2396     --#         AuditLog.State,
2397     --#         AuditLog.FileState from Status,
2398     --#                                 Screen.State,
2399     --#                                 AuditLog.State,
2400     --#                                 AuditLog.FileState,
2401     --#                                 ConfigData.State,
2402     --#                                 Clock.Now,
2403     --#                                 TheAdmin;
2404     is
2405     begin
2406        if Status = EnclaveQuiescent then
2407           if Admin.IsPresent(TheAdmin => TheAdmin) then
2408              Screen.SetMessage(Msg => Screen.RequestAdminOp);
2409           else
2410              Screen.SetMessage(Msg => Screen.WelcomeAdmin);
2411           end if;
2412        elsif Status = WaitingRemoveAdminTokenFail then
2413           Screen.SetMessage(Msg => Screen.RemoveAdminToken);
2414        end if;
2415  
2416     end ResetScreenMessage;

+++        Flow analysis of subprogram ResetScreenMessage 
           performed: no errors found.

2417  
2418  end Enclave;

Expected messages marked with the accept annotation
Type Msg    Lines              Reason                    Match
     No.  From    To                                    No.  Line
Flow  10   264   268  Ineffective assignment expected     1   265
Flow  10  1030  1034  Ineffective assignment expected     1  1031


No summarized warnings



--End of file--------------------------------------------------
